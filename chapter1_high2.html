<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chill Math CafÃ© â€” Function Compositions + Function Inversion Quest</title>
  <link rel="stylesheet" href="style.css">
</head>

<body class="game-page">
  <div class="card">
    <!-- ======== Chill Math CafÃ© Section ======== -->
    <div class="game-header">
      <div class="logo-icon">â˜•</div>
      <div>
        <h1>Chill Math CafÃ©</h1>
        <div class="sub">
          Serve comfy function-composition orders. Relaxed pace, cozy vibes â€” no pressure.
        </div>
      </div>
    </div>

    <div class="cafe">
      <aside class="left">
        <div class="barista">
          <div class="avatar">Barista</div>
          <div class="order" id="orderCard">
            <h2 id="orderTitle">Welcome!</h2>
            <p id="orderDesc">I'll explain the order when the shift begins. Click <strong>Start Shift</strong> to serve customers.</p>
            <div class="hint" id="orderHint"></div>
          </div>

          <div class="controls">
            <button id="startBtn">Start Shift</button>
            <button id="pauseBtn">Pause</button>
            <button id="giveHint">Give me a hint</button>
          </div>

          <div class="dialogue" id="dialogue">
            Barista: "Take it slow â€” breathe. Your cafe is calm. â˜ºï¸"
          </div>
        </div>
      </aside>

      <section class="right">
        <div class="counter">
          <div>
            <div class="small">Orders served</div>
            <div class="score" id="score">0</div>
          </div>
          <div>
            <div class="small">Streak</div>
            <div id="streak">0 ğŸ”¥</div>
          </div>
        </div>

        <div class="cups" id="cups"></div>

        <div class="small" style="margin-top:12px">
          Tip: Each customer requests one of <strong>fâ—¦g</strong>, <strong>gâ—¦f</strong>, <strong>fâ—¦f</strong>, or <strong>gâ—¦g</strong>. 
          Click the cup that shows the right composed formula. Use the "Give me a hint" button if stuck.
        </div>
      </section>
    </div>
</div>
    <!-- ======== Function Inversion Quest Section ======== -->
    <div class="card">
      <h1>ğŸ§  Function Inversion Quest</h1>
      <p class="small">Follow Funcyâ€™s hints, then enter the <strong>final inverse results!</strong></p>

      <!-- Levels -->
      <div class="quest-level" id="level1">
        <h2>Level 1: f(x) = -2x + 8</h2>
        <div class="steps">
          <strong>Funcyâ€™s Hints:</strong><br>
          1ï¸âƒ£ Write y = -2x + 8<br>
          2ï¸âƒ£ Swap â†’ x = -2y + 8<br>
          3ï¸âƒ£ Solve for y â†’ -2y = x - 8<br>
          4ï¸âƒ£ Simplify â†’ y = (8 - x)/2<br>
          ğŸ¯ Final Answer â†’ fâ»Â¹(x) = ?
        </div>
        <input id="inv1" placeholder="Enter fâ»Â¹(x)">
        <input id="inv1val" placeholder="Enter fâ»Â¹(-1)">
        <button onclick="check(1)">Check</button>
        <div class="result" id="res1"></div>
      </div>

      <div class="quest-level" id="level2">
        <h2>Level 2: f(x) = 3xÂ³ + 7</h2>
        <div class="steps">
          <strong>Funcyâ€™s Hints:</strong><br>
          1ï¸âƒ£ y = 3xÂ³ + 7<br>
          2ï¸âƒ£ Swap â†’ x = 3yÂ³ + 7<br>
          3ï¸âƒ£ x - 7 = 3yÂ³<br>
          4ï¸âƒ£ yÂ³ = (x - 7)/3<br>
          ğŸ¯ Final Answer â†’ fâ»Â¹(x) = ?
        </div>
        <input id="inv2" placeholder="Enter fâ»Â¹(x)">
        <input id="inv2val" placeholder="Enter fâ»Â¹(-1)">
        <button onclick="check(2)">Check</button>
        <div class="result" id="res2"></div>
      </div>

      <div class="quest-level" id="level3">
        <h2>Level 3: f(x) = (-x + 9)Â³</h2>
        <div class="steps">
          <strong>Funcyâ€™s Hints:</strong><br>
          1ï¸âƒ£ y = (-x + 9)Â³<br>
          2ï¸âƒ£ Swap â†’ x = (-y + 9)Â³<br>
          3ï¸âƒ£ Take cube root â†’ x^(1/3) = -y + 9<br>
          4ï¸âƒ£ Solve for y â†’ y = 9 - x^(1/3)<br>
          ğŸ¯ Final Answer â†’ fâ»Â¹(x) = ?
        </div>
        <input id="inv3" placeholder="Enter fâ»Â¹(x)">
        <input id="inv3val" placeholder="Enter fâ»Â¹(-1)">
        <button onclick="check(3)">Check</button>
        <div class="result" id="res3"></div>
      </div>

      <div class="quest-level" id="level4">
        <h2>Level 4: f(x) = (2x + 1)/(x - 1), x &gt; 1</h2>
        <div class="steps">
          <strong>Funcyâ€™s Hints:</strong><br>
          1ï¸âƒ£ y(x - 1) = 2x + 1<br>
          2ï¸âƒ£ Expand â†’ xy - y = 2x + 1<br>
          3ï¸âƒ£ Bring y-terms together â†’ y(x - 2) = x + 1<br>
          4ï¸âƒ£ Solve for y â†’ y = (x + 1)/(x - 2)<br>
          ğŸ¯ Final Answer â†’ fâ»Â¹(x) = ?
        </div>
        <input id="inv4" placeholder="Enter fâ»Â¹(x)">
        <input id="inv4val" placeholder="Enter fâ»Â¹(-1)">
        <button onclick="check(4)">Check</button>
        <div class="result" id="res4"></div>
      </div>

      <div id="win">ğŸ‰ You completed all levels! Funcy salutes your algebra powers! ğŸ§ ğŸš€</div>
    </div>
    
<!-- =======================
     ğŸ¹ MATH SMOOTHIE BAR GAME
     ======================= -->
<div class="card">
  <h1>ğŸ¹ Math Smoothie Bar â€” Domain & Range Mixer</h1>
  <p class="small">Help the Barista match the correct <strong>Domain</strong> and <strong>Range</strong> for each inverse function â€” no need to find the inverse!</p>

  <div class="smoothie-cards">
    <!-- Card 1 -->
    <div class="smoothie-card" data-domain="[âˆ’2, âˆ)" data-range="[0, âˆ)">
      <div class="function">f(x) = âˆš(x + 2)</div>
      <div class="mix-area">Drop your Domain and Range here ğŸ‘‡</div>
    </div>

    <!-- Card 2 -->
    <div class="smoothie-card" data-domain="x â‰  âˆ’3" data-range="y â‰  0">
      <div class="function">f(x) = 1 / (x + 3), x â‰  âˆ’3</div>
      <div class="mix-area">Drop your Domain and Range here ğŸ‘‡</div>
    </div>

    <!-- Card 3 -->
    <div class="smoothie-card" data-domain="x â‰  4" data-range="y â‰  1">
      <div class="function">f(x) = (x âˆ’ 1)/(x âˆ’ 4), x â‰  4</div>
      <div class="mix-area">Drop your Domain and Range here ğŸ‘‡</div>
    </div>

    <!-- Card 4 -->
    <div class="smoothie-card" data-domain="[5, âˆ)" data-range="[0, âˆ)">
      <div class="function">f(x) = (x âˆ’ 5)Â², x â‰¥ 5</div>
      <div class="mix-area">Drop your Domain and Range here ğŸ‘‡</div>
    </div>
  </div>

  <div class="juice-options">
    <div class="tag" draggable="true">Domain: [âˆ’2, âˆ)</div>
    <div class="tag" draggable="true">Range: [0, âˆ)</div>
    <div class="tag" draggable="true">Domain: x â‰  âˆ’3</div>
    <div class="tag" draggable="true">Range: y â‰  0</div>
    <div class="tag" draggable="true">Domain: x â‰  4</div>
    <div class="tag" draggable="true">Range: y â‰  1</div>
    <div class="tag" draggable="true">Domain: [5, âˆ)</div>
  </div>

  <div id="mixResult" class="result"></div>
</div>

<!-- ===================== LIMIT EXPLORER GAME CARD ===================== -->
<div class="card">
  <h1>ğŸ§® Limit Explorer</h1>
  <p class="small">
    Move the slider or use approach buttons to explore how each limit behaves using limit theorems.
  </p>

  <div class="limit-card">
    <div class="limit-header">
      <label for="limitSelect">Select Limit Problem:</label>
      <select id="limitSelect">
        <option value="1">(i) limâ‚“â†’3 (2x + 4)</option>
        <option value="2">(ii) limâ‚“â†’1 (3xÂ² âˆ’ 2x + 4)</option>
        <option value="3">(iii) limâ‚“â†’3 âˆš(xÂ² + x + 4)</option>
        <option value="4">(iv) limâ‚“â†’2 âˆš(xÂ² âˆ’ 4)</option>
        <option value="5">(v) limâ‚“â†’2 [âˆš(xÂ²+1) âˆ’ âˆš(xÂ²+5)]</option>
        <option value="6">(vi) limâ‚“â†’2 (2xÂ³ + 5x) / (3x âˆ’ 2)</option>
      </select>
    </div>

    <div class="limit-body">
      <canvas id="limitCanvas" width="700" height="280"></canvas>

      <div class="limit-controls">
        <label>x â†’ <span id="limitA">3</span></label>
        <input type="range" id="limitSlider" min="-5" max="5" step="0.01" value="0">
        <div class="limit-values">
          <div>x = <span id="xVal">0</span></div>
          <div>f(x) = <span id="yVal">â€”</span></div>
        </div>
      </div>

      <div class="limit-buttons">
        <button id="leftBtn">Approach Left</button>
        <button id="stopBtn" class="ghost">Stop</button>
        <button id="rightBtn">Approach Right</button>
      </div>

      <div class="limit-steps">
        <h3 id="limitTitle">Problem:</h3>
        <p id="limitDesc">Explore using the slider to approach the point.</p>
        <ul id="limitSteps"></ul>
        <div id="limitResult" class="result"></div>
      </div>
    </div>
  </div>
</div>
<!-- ==================================================================== -->
<!-- Limits Explorer â€” Calm Interactive (HTML) -->



  <div class="card">
   
    <section class="le-left">
        <div class="le-header">
    <div class="le-title">Limits Explorer â€” Calm Mode</div>
    <div class="le-sub">Move x slowly toward a, watch both sides, read step-by-step help. No pressure.</div>
        </div>
      <canvas id="leCanvas" class="le-canvas" aria-hidden="true"></canvas>

      <div class="le-info">
        <div>Problem: <span id="leProblemTitle" class="mono"></span></div>
        <div>Target a = <input id="leA" type="number" step="0.1" class="small-num" value="1" /></div>
        <div>Current x = <span id="leXVal">-2.00</span></div>
        <div>f(x) â‰ˆ <span id="leYVal">â€”</span></div>
      </div>

      <div class="le-controls">
        <button id="lePlay" class="btn">Play</button>
        <button id="leStep" class="btn ghost">Step</button>
        <button id="leReveal" class="btn ghost">Reveal Limit</button>
        <button id="leHint" class="btn ghost">Reveal Steps</button>
      </div>

      <div id="leStepsBox" class="le-steps" hidden aria-live="polite"></div>
    </section>

    <aside class="le-right">
      <div class="le-select-row">
        <label for="leProblem">Choose problem</label>
        <select id="leProblem"></select>
      </div>

      <div class="le-mode-row">
        <label>Approach side</label>
        <select id="leSide">
          <option value="both">Both sides (visual)</option>
          <option value="left">Left only (x â†’ aâ»)</option>
          <option value="right">Right only (x â†’ aâº)</option>
        </select>
      </div>

      <div class="le-slider-row">
        <label>Move x</label>
        <input id="leSlider" type="range" min="-10" max="10" step="0.01" value="-2">
      </div>

      <div class="le-extras">
        <div class="note">Tip: Slide slowly. Press Play to watch automatic approach. Click Reveal Steps to read calmly.</div>
        <div class="final-answer" id="leRevealAnswer" hidden>Limit: <span id="leAnswerText" class="mono"></span></div>
      </div>
    </aside>
  </div>
</div>

<!-- Limits Explorer 2 â€” Problems from new image -->
<div class="card"> <!-- keep your card wrapper (or ensure this sits inside one) -->
  <div id="limits-explorer-2">
    

    <div class="le2-main">
      <section class="le2-left">
        <canvas id="le2Canvas" class="le2-canvas" aria-hidden="true"></canvas>
      <div class="le2-header">
      <div class="le2-title">Limits Explorer â€” New Set</div>
      <div class="le2-sub">Calm, step-by-step view of trigonometric limits and e-limits. No pressure.</div>
      </div>
        <div class="le2-info">
          <div>Problem: <span id="le2ProblemTitle" class="le2-mono"></span></div>
          <div>Target a = <input id="le2A" type="number" step="0.1" class="le2-small-num" /></div>
          <div>Current x = <span id="le2XVal">â€”</span></div>
          <div>f(x) â‰ˆ <span id="le2YVal">â€”</span></div>
        </div>

        <div class="le2-controls">
          <button id="le2Play" class="le2-btn">Play</button>
          <button id="le2Step" class="le2-btn ghost">Step</button>
          <button id="le2Reveal" class="le2-btn ghost">Reveal Limit</button>
          <button id="le2Hint" class="le2-btn ghost">Reveal Steps</button>
        </div>

        <div id="le2StepsBox" class="le2-steps" hidden aria-live="polite"></div>
      </section>

      <aside class="le2-right">
        <div class="le2-select-row">
          <label for="le2Problem">Choose problem</label>
          <select id="le2Problem"></select>
        </div>

        <div class="le2-mode-row">
          <label>Approach side</label>
          <select id="le2Side">
            <option value="both">Both sides (visual)</option>
            <option value="left">Left only (x â†’ aâ»)</option>
            <option value="right">Right only (x â†’ aâº)</option>
          </select>
        </div>

        <div class="le2-slider-row">
          <label>Move x</label>
          <input id="le2Slider" type="range" min="-10" max="10" step="0.01" value="-2">
        </div>

        <div class="le2-extras">
          <div class="note">Tip: Slide slowly or press Play. Reveal Steps unfolds algebra slowly.</div>
          <div class="final-answer" id="le2RevealAnswer" hidden>Limit: <span id="le2AnswerText" class="le2-mono"></span></div>
        </div>
      </aside>
    </div>
  </div>
</div>

<!-- Limits Explorer 3 â€” Left/Right Visualizer (HTML) -->
<div class="card">
  <div id="le3-explorer">
   

    <div class="le3-main">
      <section class="le3-left">
        <canvas id="le3Canvas" class="le3-canvas" aria-hidden="true"></canvas>
       <div class="le3-header">
      <div class="le3-title">Limits Explorer â€” Left & Right</div>
      <div class="le3-sub">Gently explore left-hand and right-hand limits. Slide slowly or press Play.</div>
       </div>
        <div class="le3-info">
          <div>Problem: <span id="le3ProblemTitle" class="le3-mono">â€”</span></div>
          <div>Target c = <input id="le3A" type="number" step="0.1" class="le3-small-num" /></div>
          <div>Current x = <span id="le3XVal">â€”</span></div>
          <div>f(x) â‰ˆ <span id="le3YVal">â€”</span></div>
        </div>

        <div class="le3-controls">
          <button id="le3Play" class="le3-btn">Play</button>
          <button id="le3Step" class="le3-btn ghost">Step</button>
          <button id="le3Reveal" class="le3-btn ghost">Reveal Limit</button>
          <button id="le3Hint" class="le3-btn ghost">Reveal Steps</button>
        </div>

        <div id="le3StepsBox" class="le3-steps" hidden aria-live="polite"></div>
        <div id="le3RevealAnswer" class="le3-final" hidden>Limit: <span id="le3AnswerText" class="le3-mono"></span></div>
      </section>

      <aside class="le3-right">
        <div class="le3-select-row">
          <label for="le3Problem">Choose problem</label>
          <select id="le3Problem">
            <option value="p1">(i) f(x)=2xÂ² + x âˆ’ 5, c = 1</option>
            <option value="p2">(ii) f(x)=(xÂ² âˆ’ 9)/(x âˆ’ 3) â€” try c = 3 or c = -3</option>
            <option value="p3">(iii) f(x)=|x âˆ’ 5|, c = 5</option>
          </select>
        </div>

        <div class="le3-mode-row">
          <label>Approach side</label>
          <select id="le3Side">
            <option value="both">Both sides (visual)</option>
            <option value="left">Left only (x â†’ câ»)</option>
            <option value="right">Right only (x â†’ câº)</option>
          </select>
        </div>

        <div class="le3-slider-row">
          <label>Move x</label>
          <input id="le3Slider" type="range" min="-10" max="10" step="0.01" value="-2">
        </div>

        <div class="le3-extras">
          <div class="le3-note">Tip: slide slowly. Set c to 3 or -3 for problem (ii) to see difference. Steps explain algebra calmly.</div>
        </div>
      </aside>
    </div>
  </div>
</div>


<div class="card" id="continuity-garden-structured">
  <h2>ğŸŒ¼ Continuity Garden â€” Structured Questions</h2>
  <p>Each question object contains a function `f`, a default point `c`, and step-by-step notes for special c values. Edit the point if you like, then check continuity gently.</p>

  <div id="garden-structured" style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
    <div id="flowerA" class="flower">ğŸŒ±</div>
    <div id="flowerB" class="flower">ğŸŒ±</div>
    <div id="flowerC" class="flower">ğŸŒ±</div>
    <div id="flowerD" class="flower">ğŸŒ±</div>
  </div>

  <hr>

  <div id="structuredBox">
    <h3 id="pqTitle">Question</h3>

    <div style="margin-top:8px;">
      <div id="pqDisplay" style="font-size:1.02em; margin-bottom:8px;"></div>

      <label style="font-size:0.95em;">Point to check (c): </label>
      <input id="cInput" type="number" step="any" style="width:110px; padding:6px; margin-left:6px;" />
      <button class="calm-btn" onclick="checkAtC()">ğŸŒ¿ Check Continuity</button>
      <button class="calm-btn" onclick="showSteps()">ğŸ“– Show Steps</button>
      <button class="next-btn" onclick="nextStructured()">â¡ Next</button>
    </div>

    <div id="structuredResult" style="margin-top:12px; min-height:36px;"></div>

    <div id="structuredSteps" style="margin-top:12px; color:#333; line-height:1.5;"></div>
  </div>
</div>

<!-- ğŸŒ¿ LIMIT LAB (HTML-only, no voice) -->
<div class="card" id="limit-lab-html" style="margin-top:18px;">
  <h2>ğŸ”¬ Limit Lab â€” Find e</h2>

  <p style="line-height:1.6;">
    Given the piecewise function:<br>
    <b>f(x) = {</b>
    <ul style="list-style:none; margin-left:20px;">
      <li>x + 2â€ƒâ€ƒifâ€ƒx â‰¤ -1</li>
      <li>e + 2â€ƒâ€ƒifâ€ƒx &gt; -1</li>
    </ul>
    Find the value of <b>e</b> so that the limit of f(x) exists at x = -1.
  </p>

  <div class="lab-container">
    <div class="controls">
      <label for="eNumber">Set e:
        <input id="eNumber" type="number" step="0.1" value="-1" />
      </label>

      <input id="eRange" type="range" min="-5" max="5" step="0.1" value="-1" />

      <div class="buttons">
        <button class="calm-btn" id="hintBtnHtml">ğŸ’¡ Hint</button>
        <button class="calm-btn" id="revealBtnHtml">ğŸ” Reveal Answer</button>
      </div>

      <div id="labFeedbackHtml" aria-live="polite"></div>
    </div>

    <div class="visual">
      <div id="bridgeAreaHtml">
        <div class="limitBox">
          <div class="limitLabel">Left limit (x â†’ -1â»)</div>
          <div id="leftLimitHtml" class="limitValue">L = ?</div>
        </div>

        <div id="bridgeHtml" class="bridge">ğŸª„</div>

        <div class="limitBox">
          <div class="limitLabel">Right limit (x â†’ -1âº)</div>
          <div id="rightLimitHtml" class="limitValue">R = ?</div>
        </div>
      </div>

      <div id="labStepsHtml" class="labSteps" aria-live="polite"></div>
    </div>
  </div>
</div>

<!-- ===== Continuity Tile Puzzle ===== -->
<div class="card" id="continuity-tiles" style="margin-top:18px;">
  <h2>ğŸ§© Continuity Tile Puzzle</h2>
  <p style="margin-bottom:6px;">Drag the correct tiles into the slots to make the left limit, right limit and the function value match at <strong>x = 3</strong>. Try different tiles â€” when everything matches the tiles glow and you win the puzzle!</p>

  <!-- Problem (i) -->
  <div class="puzzle" id="tileProb1">
    <h3>(i)</h3>
    <div class="desc">f(x) = <span class="inline">mÂ·x</span> if x &lt; 3 &nbsp; | &nbsp; f(3) = n &nbsp; | &nbsp; f(x) = -2x + 9 if x &gt; 3</div>

    <div class="workspace">
      <div class="slot-col">
        <div class="slot-label">Left limit (x â†’ 3â»)</div>
        <div class="slot dropzone" data-slot="p1_left" aria-dropeffect="move"></div>
      </div>

      <div class="slot-col">
        <div class="slot-label">Value at 3 (f(3))</div>
        <div class="slot dropzone" data-slot="p1_value"></div>
      </div>

      <div class="slot-col">
        <div class="slot-label">Right limit (x â†’ 3âº)</div>
        <div class="slot dropzone" data-slot="p1_right"></div>
      </div>

      <div class="tiles-col">
        <div class="tiles-label">Tiles (drag these)</div>
        <div class="tiles" id="tiles1">
          <!-- tiles generated by JS; placeholder kept for structure -->
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" data-action="check" data-prob="1">Check</button>
      <button class="btn" data-action="hint" data-prob="1">Hint</button>
      <button class="btn" data-action="reset" data-prob="1">Reset</button>
      <div class="feedback" id="feedback1" aria-live="polite"></div>
    </div>
  </div>

  <hr>

  <!-- Problem (ii) -->
  <div class="puzzle" id="tileProb2">
    <h3>(ii)</h3>
    <div class="desc">f(x) = <span class="inline">mÂ·x</span> if x &lt; 3 &nbsp; | &nbsp; f(x) = xÂ² if x â‰¥ 3</div>

    <div class="workspace">
      <div class="slot-col">
        <div class="slot-label">Left limit (x â†’ 3â»)</div>
        <div class="slot dropzone" data-slot="p2_left"></div>
      </div>

      <div class="slot-col">
        <div class="slot-label">Right limit / Value at 3</div>
        <div class="slot dropzone" data-slot="p2_right"></div>
      </div>

      <div class="tiles-col">
        <div class="tiles-label">Tiles (drag these)</div>
        <div class="tiles" id="tiles2">
          <!-- tiles generated by JS -->
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" data-action="check" data-prob="2">Check</button>
      <button class="btn" data-action="hint" data-prob="2">Hint</button>
      <button class="btn" data-action="reset" data-prob="2">Reset</button>
      <div class="feedback" id="feedback2" aria-live="polite"></div>
    </div>
  </div>
</div>

<!-- ===== Rationalize Relay: Find k (interactive) ===== -->
<div class="card" id="rationalize-relay" style="margin-top:18px;">
    <div id="confettiArea" aria-hidden="true"></div>

  <h2>ğŸƒâ€â™€ï¸ Rationalize Relay â€” Find <code>k</code></h2>
  <p style="line-height:1.4;">
    Given:
    <br>
    <strong>f(x) =</strong>
    <span class="piece"> (âˆš(2x+5) âˆ’ âˆš(x+7)) / (x âˆ’ 2)  for x â‰  2</span>
    <br>and f(2) = k. Find k so that f is continuous at x = 2.
  </p>

  <div class="relay-grid">
    <!-- Left: numeric experiment -->
    <div class="panel">
      <h3>1) Try approaching x = 2</h3>
      <label>Set x (near 2): <input id="xInput" type="number" step="0.01" value="1.8" /></label>
      <input id="xRange" type="range" min="1.5" max="2.5" step="0.01" value="1.8" />
      <div class="value-row">
        <div>Expression value: <span id="exprVal">â€”</span></div>
        <div>Plugged numerator: <span id="numVal">â€”</span></div>
        <div>Plugged denominator: <span id="denVal">â€”</span></div>
      </div>
      <div style="margin-top:8px;">
        <button class="btn" id="approachBtn">Compute</button>
        <button class="btn" id="approachSeriesBtn">Try several x â†’ 2</button>
      </div>
      <div id="seriesBox" class="note-box" style="margin-top:8px; display:none;"></div>
    </div>

    <!-- Center: algebra steps -->
    <div class="panel">
      <h3>2) Rationalize (show steps)</h3>
      <div id="stepsBox" class="note-box" style="min-height:120px;">
        Click <strong>Show Steps</strong> to see how to simplify algebraically.
      </div>

      <div style="margin-top:8px;">
        <button class="btn" id="showStepsBtn">Show Steps</button>
        <button class="btn" id="hideStepsBtn">Hide Steps</button>
      </div>
    </div>

    <!-- Right: answer input -->
    <div class="panel">
      <h3>3) Set k</h3>
      <label>Enter k: <input id="kInput" type="number" step="0.0001" placeholder="e.g. 0.1667" /></label>
      <div style="margin-top:10px;">
        <button class="btn" id="checkK">Check k</button>
        <button class="btn" id="hintK">Hint</button>
        <button class="btn" id="revealK">Reveal</button>
      </div>
      <div id="kFeedback" class="k-feedback" aria-live="polite"></div>
      <div id="kSuggestion" class="note-box" style="margin-top:10px; display:none;"></div>
    </div>
  
  </div>
</div>

<!-- ğŸ¨ Graph Explorer â€” Interactive Graph Game -->
<div class="card" id="graph-explorer" style="margin-top:18px;">
  <h2>ğŸ¨ Graph Explorer â€” Explore the Curves</h2>
  <p>Click on each equation to see its graph and learn what shape it forms!</p>

  <!-- Tabs for each equation -->
  <div class="tab-row">
    <button class="tab-btn active" data-eq="eq1">(i) xÂ² + yÂ² = 9</button>
    <button class="tab-btn" data-eq="eq2">(ii) xÂ²/16 + yÂ²/4 = 1</button>
    <button class="tab-btn" data-eq="eq3">(iii) y = e^(2x)</button>
    <button class="tab-btn" data-eq="eq4">(iv) y = 3^x</button>
  </div>

  <!-- Canvas area for drawing -->
  <div class="canvas-area">
    <canvas id="graphCanvas" width="420" height="300"></canvas>
  </div>

  <div class="info-area">
    <button class="calm-btn" id="hintBtn">ğŸ’¡ Show Hint</button>
    <div id="hintBox" class="hint-box"></div>
  </div>
</div>

<!-- ğŸ¡ Parametric Playground â€” Interactive Graphs -->
<div class="card" id="parametric-playground" style="margin-top:18px;">
  <h2>ğŸ¡ Parametric Playground â€” Explore Parametric Curves</h2>
  <p>
    Move the slider or press â€œAnimateâ€ to see how <b>x</b> and <b>y</b> change with the parameter (<b>t</b> or <b>Î¸</b>).
    <br>Select each equation to view its graph:
  </p>

  <div class="tab-row">
    <button class="tab-btn active" data-eq="p1">(i) x = t, y = tÂ²</button>
    <button class="tab-btn" data-eq="p2">(ii) x = tâˆ’1, y = 2tâˆ’1</button>
    <button class="tab-btn" data-eq="p3">(iii) x = sec(Î¸), y = tan(Î¸)</button>
  </div>

  <div class="canvas-area">
    <canvas id="paramCanvas" width="420" height="300"></canvas>
  </div>

  <div class="controls">
    <label id="paramLabel">t:</label>
    <input type="range" id="paramRange" min="-3" max="3" step="0.05" value="-3">
    <span id="paramValue">-3.00</span>
    <button class="calm-btn" id="animateBtn">â–¶ Animate</button>
    <button class="calm-btn" id="resetBtn">âŸ³ Reset</button>
  </div>

  <div class="info-area">
    <button class="btn">ğŸ’¡ Show Hint</button>
    <div id="hintBox" class="hint-box"></div>
  </div>
</div>

<!-- ğŸ§© Continuity Explorer â€” SVG Version -->
<div class="card" id="continuity-lab">
  <h2>ğŸ§© Continuity Explorer â€” Test for Continuity</h2>
  <p>Switch functions and move the slider to explore behavior near critical points.</p>

  <div class="tab-row">
    <button class="tab-btn active" data-eq="f1">(i) y = xâˆ’1 (x&lt;3), 2x+1 (xâ‰¥3)</button>
    <button class="tab-btn" data-eq="f2">(ii) y = (xÂ²âˆ’4)/(xâˆ’2)</button>
    <button class="tab-btn" data-eq="f3">(iii) y = x+3 (xâ‰ 3), 2 (x=3)</button>
    <button class="tab-btn" data-eq="f4">(iv) y = (xÂ²âˆ’16)/(xâˆ’4)</button>
  </div>

  <div class="svg-area">
    <svg id="graph" width="480" height="320" viewBox="0 0 480 320">
      <line x1="0" y1="160" x2="480" y2="160" stroke="#aaa"/>
      <line x1="240" y1="0" x2="240" y2="320" stroke="#aaa"/>
      <path id="graphPath" stroke="#3b82f6" stroke-width="2" fill="none"></path>
      <circle id="point" r="4" fill="#3b82f6"></circle>
      <circle id="hole" r="5" fill="none" stroke="#ef4444" stroke-width="2"></circle>
      <circle id="filled" r="5" fill="#ef4444"></circle>
    </svg>
  </div>

  <div class="controls">
    <label>x:</label>
    <input type="range" id="xSlider" min="0" max="6" step="0.05" value="0">
    <span id="xValue">0.00</span>
  </div>

  <div class="hint-box" id="hintBox"></div>
  <button class="calm-btn" id="hintBtn">ğŸ’¡ Show Hint</button>
</div>

<!-- ========== Trig Match Game (HTML) ========== -->
<div id="trig-game-card" class="card">
  <h2>ğŸ¯ Trigonometric Match Game â€” Graphical Solutions</h2>
  <p>Pick an equation, view both sides on the graph.</p>
  <div id="eqButtons" class="eq-buttons">
    <button class="eq-btn active" data-eq="eq1"> (i) x = sin(2x) </button>
    <button class="eq-btn" data-eq="eq2"> (ii) x/2 = cos(x) </button>
    <button class="eq-btn" data-eq="eq3"> (iii) 2x = tan(x) </button>
  </div>

  <div class="canvas-wrap" style="display:flex; justify-content:center;">
    <canvas id="gameCanvas" width="760" height="420" aria-label="Graph canvas"></canvas>
  </div>

 

  <div id="stepsBox" class="steps-box" aria-live="polite" style="margin-top:12px; min-height:90px;">
    <!-- Steps and summaries will appear here -->
  </div>
</div>


  <!-- Overlay Modal -->
  <div class="overlay" id="overlay">
    <div class="modal" id="modalText"></div>
  </div>

  <script>
    /* =============== Chill Math CafÃ© Logic =============== */
    const problems = [
      { f: '2x + 1', g: '3/(x - 1)', note: 'x â‰  1' },
      { f: 'âˆš(x + 1)', g: '1/x^2', note: 'x â‰  0' },
      { f: '1/âˆš(x - 1)', g: '(x^2 + 1)^2', note: 'x â‰  1' },
      { f: '3x^4 - 2x^2', g: '2/âˆšx', note: 'x â‰  0' }
    ];

    const compNames = [
      { code: 'fog', label: '(f âˆ˜ g)(x) â€” f(g(x))' },
      { code: 'gof', label: '(g âˆ˜ f)(x) â€” g(f(x))' },
      { code: 'fof', label: '(f âˆ˜ f)(x) â€” f(f(x))' },
      { code: 'gog', label: '(g âˆ˜ g)(x) â€” g(g(x))' }
    ];

    function composeText(type, f, g) {
      if (type === 'fog') return 'f(g(x)) = ' + f.replace(/x/g, '(' + g + ')');
      if (type === 'gof') return 'g(f(x)) = ' + g.replace(/x/g, '(' + f + ')');
      if (type === 'fof') return 'f(f(x)) = ' + f.replace(/x/g, '(' + f + ')');
      if (type === 'gog') return 'g(g(x)) = ' + g.replace(/x/g, '(' + g + ')');
      return '';
    }

    let orderQueue = [], current = null, served = 0, streak = 0, paused = false;

    const orderTitle = document.getElementById('orderTitle');
    const orderDesc = document.getElementById('orderDesc');
    const orderHint = document.getElementById('orderHint');
    const cupsEl = document.getElementById('cups');
    const scoreEl = document.getElementById('score');
    const streakEl = document.getElementById('streak');
    const dialogue = document.getElementById('dialogue');
    const overlay = document.getElementById('overlay');
    const modalText = document.getElementById('modalText');

    document.getElementById('startBtn').addEventListener('click', startShift);
    document.getElementById('pauseBtn').addEventListener('click', () => {
      paused = !paused;
      document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
      showMsg(paused ? 'Shift paused. Take a breath.' : 'Back to serving!');
    });
    document.getElementById('giveHint').addEventListener('click', () => {
      if (current) showHint(); else showMsg('No current order yet. Start the shift!');
    });

    function startShift() {
      orderQueue = [];
      for (let p of problems) {
        const picks = ['fog', 'gof', 'fof', 'gog'].sort(() => Math.random() - 0.5).slice(0, 2);
        for (let t of picks) orderQueue.push({ p, t });
      }
      orderQueue.sort(() => Math.random() - 0.5);
      served = 0; streak = 0;
      updateScore(); nextOrder();
      showMsg('Shift started â€” welcome to the Chill Math CafÃ©!');
    }

    function nextOrder() {
      if (paused) return;
      if (orderQueue.length === 0) { showModal('All customers served â€” nice work! Take a break â˜•'); return; }
      current = orderQueue.shift(); renderOrder(current);
    }

    function renderOrder({ p, t }) {
      orderTitle.textContent = `Customer order: ${compNames.find(c => c.code === t).label}`;
      orderDesc.innerHTML = `f(x) = <strong>${p.f}</strong><br>g(x) = <strong>${p.g}</strong><br><span class='small'>${p.note}</span>`;
      orderHint.textContent = '';
      const correct = composeText(t, p.f, p.g);
      const opts = makeCups(correct, p, t);
      renderCups(opts, correct);
    }

    function makeCups(correct, p, t) {
      const swapped = composeText(t.replace('f', 'TEMP').replace('g', 'f').replace('TEMP', 'g'), p.f, p.g);
      const careless = correct.replace(/\(/g, '').replace(/\)/g, '');
      return [correct, careless, swapped].sort(() => Math.random() - 0.5);
    }

    function renderCups(opts, correct) {
      cupsEl.innerHTML = '';
      for (let text of opts) {
        const cup = document.createElement('div');
        cup.className = 'cup';
        cup.innerHTML = `<div class="top">â˜•</div><div class="text">${escapeHtml(text)}</div>`;
        cup.addEventListener('click', () => chooseCup(cup, text, correct));
        cupsEl.appendChild(cup);
      }
    }

    function chooseCup(cup, text, correct) {
      if (paused) return showMsg('Resume the shift to serve.');
      if (text === correct) {
        cup.classList.add('correct'); served++; streak++; showMsg('Customer: "Perfect! Thank you ğŸ˜Š"');
        setTimeout(() => { updateScore(); setTimeout(nextOrder, 800); }, 600);
      } else {
        cup.classList.add('wrong'); streak = 0; showMsg('Customer: "Hmm, thatâ€™s not right â€” try again."');
      }
      updateScore();
    }

    function updateScore() { scoreEl.textContent = served; streakEl.textContent = (streak > 0 ? streak : '0') + ' ğŸ”¥'; }
    function showHint() { if (!current) return; orderHint.textContent = 'Hint: Replace x carefully and watch parentheses.'; }
    function showMsg(msg) { dialogue.textContent = 'Barista: "' + msg + '"'; }
    function showModal(text) { modalText.innerHTML = `<h3>${text}</h3><p style="margin-top:12px"><button onclick="closeModal()">Continue</button></p>`; overlay.classList.add('show'); }
    function closeModal() { overlay.classList.remove('show'); }
    function escapeHtml(s) { return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }

    /* =============== Function Inversion Quest Logic =============== */
    const answers = {
      1: { inv: "(8-x)/2", val: "4.5" },
      2: { inv: "((x-7)/3)^(1/3)", val: "-(8/3)^(1/3)" },
      3: { inv: "9-x^(1/3)", val: "10" },
      4: { inv: "(x+1)/(x-2)", val: "0" }
    };

    let score2 = 0;
    function normalize(str) { return str.replace(/\s+/g, '').replaceAll('**', '^').toLowerCase(); }

    function check(level) {
      const inv = normalize(document.getElementById(`inv${level}`).value);
      const val = normalize(document.getElementById(`inv${level}val`).value);
      const res = document.getElementById(`res${level}`);
      if (inv === normalize(answers[level].inv) && val === normalize(answers[level].val)) {
        res.innerHTML = "âœ… Correct! Funcy dances happily!";
        res.className = "result success";
        score2++;
      } else {
        res.innerHTML = "âŒ Oops! Check your algebra and try again!";
        res.className = "result error";
      }
      if (score2 === 4) document.getElementById("win").style.display = "block";
    }


/* ğŸ¹ DOMAIN & RANGE MIXER LOGIC */
const tags = document.querySelectorAll(".tag");
const cards = document.querySelectorAll(".smoothie-card");
const mixResult = document.getElementById("mixResult");
let currentDragged = null;

tags.forEach(tag => {
  tag.addEventListener("dragstart", e => {
    currentDragged = e.target;
    e.target.style.opacity = "0.6";
  });
  tag.addEventListener("dragend", e => e.target.style.opacity = "1");
});

cards.forEach(card => {
  card.addEventListener("dragover", e => e.preventDefault());
  card.addEventListener("drop", e => {
    e.preventDefault();
    const mixArea = card.querySelector(".mix-area");
    const text = currentDragged.textContent;
    if (!mixArea.textContent.includes(text)) {
      mixArea.innerHTML += `<div>${text}</div>`;
    }
    checkMatch(card);
  });
});

function checkMatch(card) {
  const mixText = card.querySelector(".mix-area").textContent;
  const domain = card.dataset.domain;
  const range = card.dataset.range;
  if (mixText.includes(domain) && mixText.includes(range)) {
    card.classList.add("correct");
    mixResult.innerHTML = `âœ… Perfect mix! You matched ${card.querySelector(".function").textContent}`;
    mixResult.className = "result success";
  }
}



/* ------------------- Limit Explorer Script (Fixed) ------------------- */

const limitProblems = {
  1: { expr: x => 2*x + 4, a: 3, steps: ["Polynomial â†’ continuous.", "Apply substitution.", "f(3)=10"], result: "10" },
  2: { expr: x => 3*x*x - 2*x + 4, a: 1, steps: ["Polynomial â†’ continuous.", "Direct substitution.", "f(1)=5"], result: "5" },
  3: { expr: x => Math.sqrt(x*x + x + 4), a: 3, steps: ["Inside polynomial continuous.", "Direct substitution.", "âˆš(3Â²+3+4)=âˆš16=4"], result: "4" },
  4: { expr: x => (x*x - 4 >= 0 ? Math.sqrt(x*x - 4) : NaN), a: 2, steps: ["Domain: xâ‰¤âˆ’2 or xâ‰¥2.", "Left side invalid â†’ Right-hand limit only.", "limâ†’2âº âˆš(xÂ²âˆ’4)=0"], result: "Right-hand = 0" },
  5: { expr: x => Math.sqrt(x*x+1)-Math.sqrt(x*x+5), a: 2, steps: ["Continuous under root.", "Direct substitution.", "âˆš5âˆ’3 â‰ˆ -0.764"], result: "â‰ˆ -0.764" },
  6: { expr: x => (3*x-2!==0)?(2*x*x*x+5*x)/(3*x-2):NaN, a: 2, steps: ["Rational function.", "Denominator nonzero.", "f(2)=26/4=6.5"], result: "6.5" },
};

const limitSelect = document.getElementById("limitSelect");
const limitCanvas = document.getElementById("limitCanvas");
const ctx2 = limitCanvas.getContext("2d");
const limitSlider = document.getElementById("limitSlider");
const xValEl = document.getElementById("xVal");
const yValEl = document.getElementById("yVal");
const limitTitle = document.getElementById("limitTitle");
const limitDesc = document.getElementById("limitDesc");
const limitSteps = document.getElementById("limitSteps");
const limitResult = document.getElementById("limitResult");

const leftBtn = document.getElementById("leftBtn");
const rightBtn = document.getElementById("rightBtn");
const stopBtn = document.getElementById("stopBtn");

let limitCurrent = 1;  // âœ… renamed
let limitAnimId = null;
let limitA = 3;

/* Draw the function graph */
function drawLimitGraph() {
  ctx2.clearRect(0, 0, limitCanvas.width, limitCanvas.height);
  ctx2.beginPath();
  ctx2.strokeStyle = "#f0c087"; // orange accent
  ctx2.lineWidth = 2;

  for (let x = -5; x <= 5; x += 0.05) {
    const y = limitProblems[limitCurrent].expr(x);
    if (isNaN(y)) continue;
    const px = 350 + x * 60;
    const py = 140 - y * 25;
    if (x === -5) ctx2.moveTo(px, py);
    else ctx2.lineTo(px, py);
  }
  ctx2.stroke();

  // Mark limit point
  const yA = limitProblems[limitCurrent].expr(limitA);
  if (!isNaN(yA)) {
    ctx2.beginPath();
    ctx2.arc(350 + limitA * 60, 140 - yA * 25, 6, 0, Math.PI * 2);
    ctx2.fillStyle = "#ffb347";
    ctx2.fill();
  }
}

/* Update slider display */
function updateLimit() {
  const x = parseFloat(limitSlider.value);
  const f = limitProblems[limitCurrent].expr(x);
  xValEl.textContent = x.toFixed(2);
  yValEl.textContent = isNaN(f) ? "undefined" : f.toFixed(3);
  drawLimitGraph();
}

/* Load problem data */
function loadLimitProblem(n) {
  limitCurrent = parseInt(n);
  const p = limitProblems[limitCurrent];
  limitA = p.a;
  document.getElementById("limitA").textContent = limitA;
  limitTitle.textContent = `Problem ${n}`;
  limitDesc.textContent = p.steps[0];
  limitSteps.innerHTML = p.steps.map(s => `<li>${s}</li>`).join("");
  limitResult.textContent = `Limit = ${p.result}`;
  updateLimit();
}

/* Animate approach */
function animateApproach(dir) {
  cancelAnimationFrame(limitAnimId);
  const p = limitProblems[limitCurrent];
  const start = dir === "left" ? p.a - 3 : p.a + 3;
  const end = p.a;
  let x = start;
  function step() {
    if ((dir === "left" && x < end) || (dir === "right" && x > end)) return;
    limitSlider.value = x;
    updateLimit();
    x += dir === "left" ? 0.05 : -0.05;
    limitAnimId = requestAnimationFrame(step);
  }
  step();
}

function stopApproach() {
  cancelAnimationFrame(limitAnimId);
}

/* Event bindings */
limitSelect.addEventListener("change", e => loadLimitProblem(e.target.value));
limitSlider.addEventListener("input", updateLimit);
leftBtn.addEventListener("click", () => animateApproach("left"));
rightBtn.addEventListener("click", () => animateApproach("right"));
stopBtn.addEventListener("click", stopApproach);

/* Initialize */
loadLimitProblem(1);

/* Limits Explorer â€” interactive logic (IIFE, safe to drop) */
(function() {
  const problems = [
    { id:1, title:"(i) lim_{xâ†’1} (x^3 - x)/(x + 1)", fExpr:"(x*x*x - x)/(x + 1)", hint:"Try substitute x=1 first.", steps:["Substitute x=1: numerator 0, denominator 2 â†’ 0. So limit = 0."], ans:0, aDefault:1 },
    { id:2, title:"(ii) lim_{xâ†’0} (3x^3 + 4x)/(x^2 + x)", fExpr:"(3*x*x*x + 4*x)/(x*x + x)", hint:"Factor x from numerator and denominator.", steps:["Factor x: x(3x^2+4)/x(x+1). Cancel x â†’ (3x^2+4)/(x+1). Substitute x=0 gives 4."], ans:4, aDefault:0 },
    { id:3, title:"(iii) lim_{xâ†’2} (x^3 - 8)/(x^2 + x - 6)", fExpr:"(x*x*x - 8)/(x*x + x - 6)", hint:"Factor (x-2) and cancel.", steps:["x^3-8=(x-2)(x^2+2x+4). Denominator=(x-2)(x+3). Cancel (x-2). Substitute x=2 â†’ 12/5."], ans:12/5, aDefault:2 },
    { id:4, title:"(iv) lim_{xâ†’1} (x^3 - 3x^2 + 3x - 1)/(x^3 - x)", fExpr:"(x*x*x - 3*x*x + 3*x - 1)/(x*x*x - x)", hint:"Numerator is (x-1)^3; cancel (x-1).", steps:["Simplify and substitute â†’ 0."], ans:0, aDefault:1 },
    { id:5, title:"(v) lim_{xâ†’1} (x^3 + x^2)/(x^2 - 1)", fExpr:"(x*x*x + x*x)/(x*x - 1)", hint:"Denominator â†’ 0, check one-sided limits.", steps:["Substitute x=1: numerator 2, denominator 0. One side â†’ +âˆ, other â†’ -âˆ â†’ limit does not exist."], ans:null, aDefault:1 },
    { id:6, title:"(vi) lim_{xâ†’4} (2x^2 - 32)/(x^3 - 4x^2)", fExpr:"(2*x*x - 32)/(x*x*x - 4*x*x)", hint:"Factor (x-4) and cancel.", steps:["Simplify to 2(x+4)/x^2 and substitute x=4 â†’ 1."], ans:1, aDefault:4 },
    { id:7, title:"(vii) lim_{xâ†’2} (sqrt(x) - sqrt(2))/(x - 2)", fExpr:"(Math.sqrt(x) - Math.sqrt(2))/(x - 2)", hint:"Multiply by conjugate.", steps:["Multiply by (âˆšx+âˆš2): result â†’ 1/(âˆšx+âˆš2). Substitute x=2 â†’ 1/(2âˆš2)."], ans:1/(2*Math.sqrt(2)), aDefault:2 },
    { id:8, title:"(viii) lim_{hâ†’0} (sqrt(x+h) - sqrt(x))/h", fExpr:null, hint:"This is derivative of sqrt(x): 1/(2âˆšx).", steps:["Multiply by conjugate; letting hâ†’0 gives 1/(2âˆšx)."], ans:'symbolic', aDefault:0 },
    { id:9, title:"(ix) lim_{xâ†’a} (x^n - a^n)/(x - a)", fExpr:null, hint:"Standard formula: n * a^(n-1).", steps:["Factor and cancel â†’ n * a^(n-1)."], ans:'formula', aDefault:1 }
  ];

  // DOM
  const root = document.getElementById('limits-explorer');
  if (!root) return;
  const canvas = root.querySelector('#leCanvas');
  const ctx = canvas.getContext('2d');
  const problemSelect = root.querySelector('#leProblem');
  const slider = root.querySelector('#leSlider');
  const aInput = root.querySelector('#leA');
  const xVal = root.querySelector('#leXVal');
  const yVal = root.querySelector('#leYVal');
  const playBtn = root.querySelector('#lePlay');
  const stepBtn = root.querySelector('#leStep');
  const revealBtn = root.querySelector('#leReveal');
  const hintBtn = root.querySelector('#leHint');
  const stepsBox = root.querySelector('#leStepsBox');
  const problemTitle = root.querySelector('#leProblemTitle');
  const sideSelect = root.querySelector('#leSide');
  const revealAnswer = root.querySelector('#leRevealAnswer');
  const revealText = root.querySelector('#leAnswerText');

  // state
  let idx = 0;
  let a = problems[0].aDefault;
  let x = parseFloat(slider.value);
  let playing = false;
  let leftX = x - 1.6, rightX = x + 1.6;
  let raf = null;

  // canvas sizing
  function resize() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    draw();
  }
  window.addEventListener('resize', resize);
  resize();

  // populate problems dropdown
  problems.forEach((p, i) => {
    const opt = document.createElement('option'); opt.value = i; opt.textContent = p.title;
    problemSelect.appendChild(opt);
  });

  // utilities
  function safeEvalF(expr, xv) {
    try {
      if (!expr) return NaN;
      return Function('x','return (' + expr + ')')(xv);
    } catch (e) { return NaN; }
  }

  function setProblem(i) {
    idx = i;
    const p = problems[i];
    problemTitle.textContent = p.title;
    a = ('aDefault' in p) ? p.aDefault : 1;
    aInput.value = a;
    revealAnswer.hidden = true;
    stepsBox.hidden = true;
    revealText.textContent = '';
    // set slider to a sensible start
    slider.value = Math.max(-9, Math.min(9, a - 3));
    x = parseFloat(slider.value);
    leftX = x - 1; rightX = x + 1;
    draw();
  }

  // draw axes + function + approach points
  function draw() {
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    // background
    ctx.fillStyle = '#f8fafc'; ctx.fillRect(0,0,w,h);

    // transform: map x in [a-6, a+6] to canvas width
    const span = 6;
    const xmin = a - span, xmax = a + span;
    const ymin = -5, ymax = 5;

    function toPx(mx,my) { const px = (mx - xmin)/(xmax - xmin) * w; const py = (1 - (my - ymin)/(ymax - ymin)) * h; return {x:px,y:py}; }

    // draw grid
    ctx.strokeStyle = 'rgba(15,23,42,0.06)'; ctx.lineWidth = 1;
    for (let gx = Math.ceil(xmin); gx <= Math.floor(xmax); gx++) {
      const p = toPx(gx,0); ctx.beginPath(); ctx.moveTo(p.x,0); ctx.lineTo(p.x,h); ctx.stroke();
    }

    // x-axis
    const y0 = toPx(a,0).y; ctx.strokeStyle = 'rgba(15,23,42,0.12)'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(w,y0); ctx.stroke();

    // target vertical line at x=a
    const pa = toPx(a,0); ctx.strokeStyle = 'rgba(99,102,241,0.18)'; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(pa.x,0); ctx.lineTo(pa.x,h); ctx.stroke(); ctx.setLineDash([]);

    // draw function
    const p = problems[idx];
    if (p.fExpr) {
      ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2.2; ctx.beginPath();
      const steps = Math.max(120, Math.floor(w/3));
      for (let i=0;i<=steps;i++){
        const t = i/steps; const mx = xmin + t*(xmax-xmin);
        const my = safeEvalF(p.fExpr, mx);
        if (!isFinite(my)) { ctx.moveTo(-100,-100); continue; }
        const pt = toPx(mx,my);
        if (i===0) ctx.moveTo(pt.x,pt.y); else ctx.lineTo(pt.x,pt.y);
      }
      ctx.stroke();
    } else {
      // function undefined (symbolic) â€” show subtle text
      ctx.fillStyle = 'rgba(15,23,42,0.12)'; ctx.font = '14px Inter, sans-serif'; ctx.fillText('Function is symbolic for this problem', 14, 20);
    }

    // compute left/right y
    const leftMode = (sideSelect.value === 'left');
    const rightMode = (sideSelect.value === 'right');
    const leftTarget = (sideSelect.value === 'right') ? a + 0.01 : a - 0.001;
    const rightTarget = (sideSelect.value === 'left') ? a - 0.01 : a + 0.001;

    // approach nodes: leftX & rightX move slowly toward targets or toward slider mean
    const mean = x;
    leftX += (Math.min(a-0.0005, mean) - leftX) * 0.08;
    rightX += (Math.max(a+0.0005, mean) - rightX) * 0.08;

    const yL = p.fExpr ? safeEvalF(p.fExpr, leftX) : NaN;
    const yR = p.fExpr ? safeEvalF(p.fExpr, rightX) : NaN;

    // draw left point
    if (isFinite(yL)) {
      const pL = toPx(leftX, yL);
      drawGlow(pL.x, pL.y, 20, 'rgba(124,58,237,0.08)');
      drawDot(pL.x, pL.y, 10, '#7c3aed');
    }
    // draw right point
    if (isFinite(yR)) {
      const pR = toPx(rightX, yR);
      drawGlow(pR.x, pR.y, 16, 'rgba(96,165,250,0.07)');
      drawDot(pR.x, pR.y, 8, '#2563eb');
    }

    // update numeric displays using the mean of visible points
    const visX = (leftX + rightX) / 2;
    const visY = p.fExpr ? safeEvalF(p.fExpr, visX) : NaN;
    xVal.textContent = visX.toFixed(3);
    yVal.textContent = isFinite(visY) ? visY.toFixed(4) : 'â€”';

    // helper drawing functions
    function drawDot(cx,cy,r,fill) { ctx.save(); ctx.beginPath(); ctx.fillStyle = fill; ctx.shadowColor = fill; ctx.shadowBlur = 12; ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    function drawGlow(cx,cy,rad,color) { ctx.save(); ctx.fillStyle = color; ctx.beginPath(); ctx.ellipse(cx,cy,rad,rad/2,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  }

  // animation loop when playing
  function animate() {
    if (!playing) { if (raf) cancelAnimationFrame(raf); raf = null; return; }
    // nudge slider toward a
    const cur = parseFloat(slider.value);
    const delta = (a - cur) * 0.02;
    slider.value = (cur + delta).toFixed(3);
    x = parseFloat(slider.value);
    draw();
    raf = requestAnimationFrame(animate);
  }

  // controls
  problemSelect.addEventListener('change', ()=> setProblem(parseInt(problemSelect.value)));
  slider.addEventListener('input', ()=> { x = parseFloat(slider.value); leftX = x - 0.6; rightX = x + 0.6; draw(); });
  aInput.addEventListener('input', ()=> { a = parseFloat(aInput.value); draw(); });
  sideSelect.addEventListener('change', ()=> draw());

  playBtn.addEventListener('click', ()=>{
    playing = !playing;
    playBtn.textContent = playing ? 'Pause' : 'Play';
    if (playing) animate(); else { if (raf) cancelAnimationFrame(raf); raf = null; }
  });

  stepBtn.addEventListener('click', ()=>{
    // gently move both points closer to a
    leftX += (a - leftX) * 0.3;
    rightX += (a - rightX) * 0.3;
    // move slider to mean
    const mean = (leftX + rightX) / 2;
    slider.value = mean.toFixed(3); x = mean;
    draw();
  });

  hintBtn.addEventListener('click', ()=> {
    stepsBox.hidden = false;
    stepsBox.innerHTML = '';
    const steps = problems[idx].steps || [];
    steps.forEach((s, i) => {
      const d = document.createElement('div'); d.textContent = s;
      d.style.opacity = '0'; d.style.transform = 'translateX(-6px)'; d.style.transition = `all 280ms ease ${i*100}ms`;
      stepsBox.appendChild(d);
      requestAnimationFrame(()=>{ d.style.opacity='1'; d.style.transform='none'; });
    });
  });

  revealBtn.addEventListener('click', ()=> {
    const p = problems[idx];
    revealAnswer.hidden = false;
    if (p.ans === 'symbolic') revealText.textContent = '1 / (2 * âˆšx)  (symbolic)';
    else if (p.ans === 'formula') revealText.textContent = 'n * a^(n-1) (formula)';
    else if (p.ans === null) revealText.textContent = 'Does not exist (one-sided infinities differ)';
    else revealText.textContent = p.ans.toString();
  });

  // initialize default problem
  setProblem(0);

  // set select default and initial render
  problemSelect.value = '0';
  draw();

})();

/* Limits Explorer 2 â€” interactive logic (IIFE, safe to drop) */
(function() {
  const problems = [
    // Trig limits group (1..12)
    { id:'1', title:"(i) limâ‚“â†’0 sin(7x)/x", fExpr:"Math.sin(7*x)/x", hint:"Use sin(kx)â‰ˆkx â†’ limit = 7", steps:["For small x: sin(7x)â‰ˆ7x â‡’ (7x)/x = 7"], ans:7, aDefault:0 },
    { id:'2', title:"(ii) limâ‚“â†’0 sin(x^0)/x", fExpr:null, hint:"sin(x^0) usually equals sin(1) if x^0 interpreted as 1; expression â†’ sin(1)/0 (undefined). If this is sin(x)^0 =1 â†’ 1/x â†’ âˆ. Clarify notation.", steps:["This item is ambiguous â€” usually notation needs correction."], ans:null, aDefault:0 },
    { id:'3', title:"(iii) lim_{Î¸â†’0} (1 - cos Î¸)/sin Î¸", fExpr:null, hint:"Use small-angle expansions", steps:["cos Î¸ â‰ˆ 1 - Î¸^2/2, sin Î¸ â‰ˆ Î¸ â‡’ (1 - cos Î¸)/sin Î¸ â‰ˆ (Î¸^2/2)/Î¸ = Î¸/2 â‡’ 0"], ans:0, aDefault:0 },
    { id:'4', title:"(iv) lim_{xâ†’Ï€} sin x/(Ï€ - x)", fExpr:"Math.sin(x)/(Math.PI - x)", hint:"Let h=Ï€-x; sin x = sin(Ï€ - h)=sin h â‰ˆ h â‡’ limit = 1", steps:["Let h=Ï€-x â†’ sin x = sin h â‰ˆ h; denominator = h â‡’ 1"], ans:1, aDefault:Math.PI },
    { id:'5', title:"(v) lim_{xâ†’0} sin(a x)/sin(b x)", fExpr:"Math.sin( a_val * x )/Math.sin( b_val * x )", hint:"Use small-angle: sin(kx)â‰ˆkx â‡’ a/b", steps:["sin(ax)â‰ˆax, sin(bx)â‰ˆbx â‡’ ratio a/b"], ans:'a_over_b', aDefault:0 },
    { id:'6', title:"(vi) lim_{xâ†’0} x / tan x", fExpr:"x/Math.tan(x)", hint:"tan x â‰ˆ x â‡’ limit = 1", steps:["tan xâ‰ˆx â‡’ x/tan x â‰ˆ 1"], ans:1, aDefault:0 },
    { id:'7', title:"(vii) lim_{xâ†’0} (1 - cos 2x)/x^2", fExpr:"(1 - Math.cos(2*x))/(x*x)", hint:"Use cos expansion: 1 - cos2x â‰ˆ (2x)^2/2 = 2x^2 â‡’ limit 2", steps:["1-cos2xâ‰ˆ(2x)^2/2=2x^2 â‡’ divide by x^2 gives 2"], ans:2, aDefault:0 },
    { id:'8', title:"(viii) lim_{xâ†’0} (1 - cos x)/sin^2 x", fExpr:"(1 - Math.cos(x))/(Math.sin(x)*Math.sin(x))", hint:"Use expansions: (1-cos x)â‰ˆx^2/2 and sin^2 xâ‰ˆx^2 â‡’ 1/2", steps:["(1-cos x)â‰ˆx^2/2; sin^2 xâ‰ˆx^2 â‡’ ratio = 1/2"], ans:0.5, aDefault:0 },
    { id:'9', title:"(ix) lim_{Î¸â†’0} sin^2 Î¸ / Î¸", fExpr:"(Math.sin(x)*Math.sin(x))/x", hint:"sin^2 Î¸ â‰ˆ Î¸^2 â‡’ Î¸^2/Î¸ = Î¸ â†’ 0", steps:["sin^2Î¸â‰ˆÎ¸^2 â‡’ Î¸^2/Î¸ = Î¸ â‡’ 0"], ans:0, aDefault:0 },
    { id:'10', title:"(x) lim_{xâ†’0} (sec x - cos x)/x", fExpr:"(1/Math.cos(x) - Math.cos(x))/x", hint:"Use expansions; result 0", steps:["sec x â‰ˆ1 + x^2/2, cos x â‰ˆ1 - x^2/2 â‡’ difference â‰ˆ x^2 â‡’ divide by x â†’ 0"], ans:0, aDefault:0 },
    { id:'11', title:"(xi) lim_{Î¸â†’0} (1 - cos pÎ¸)/(1 - cos qÎ¸)", fExpr:null, hint:"Use small-angle: (1-cos kÎ¸)â‰ˆ(k^2 Î¸^2)/2 â‡’ ratio p^2/q^2", steps:["Ratio â‰ˆ (p^2 Î¸^2/2)/(q^2 Î¸^2/2)=p^2/q^2"], ans:'p2_over_q2', aDefault:0 },
    { id:'12', title:"(xii) lim_{Î¸â†’0} (tan Î¸ - sin Î¸)/sin^3 Î¸", fExpr:"(Math.tan(x) - Math.sin(x))/Math.pow(Math.sin(x),3)", hint:"Use Taylor expansions â†’ 1/2", steps:["tanâ‰ˆÎ¸+Î¸^3/3, sinâ‰ˆÎ¸-Î¸^3/6 â‡’ difference â‰ˆ Î¸^3(1/3+1/6)=Î¸^3/2 â‡’ /Î¸^3 â†’ 1/2"], ans:0.5, aDefault:0 },

    // e-limits group (13..18)
    { id:'13', title:"(i) lim_{nâ†’âˆ} (1 + 1/n)^{2n}", fExpr:null, hint:"(1+1/n)^nâ†’e â‡’ ( )^{2} â†’ e^2", steps:["(1+1/n)^n â†’ e â‡’ power 2n gives e^2"], ans:'e^2', aDefault:1 },
    { id:'14', title:"(ii) lim_{nâ†’âˆ} (1 + 1/n)^{n/2}", fExpr:null, hint:"(1+1/n)^nâ†’e, so exponent n/2 â‡’ e^{1/2}", steps:["(1+1/n)^n â†’ e â‡’ ( )^{1/2} = âˆše"], ans:'e^(1/2)', aDefault:1 },
    { id:'15', title:"(iii) lim_{nâ†’âˆ} (1 - 1/n)^n", fExpr:null, hint:"(1 - 1/n)^n â†’ e^{-1}", steps:["Limit equals e^{-1}"], ans:'e^-1', aDefault:1 },
    { id:'16', title:"(iv) lim_{nâ†’âˆ} (1 + 1/(3n))^{n}", fExpr:null, hint:"(1 + 1/(3n))^{n} â†’ e^{1/3}", steps:["(1+1/(3n))^{3n}â†’e â‡’ exponent n gives e^{1/3}"], ans:'e^(1/3)', aDefault:1 },
    { id:'17', title:"(v) lim_{nâ†’âˆ} (1 + 4/n)^n", fExpr:null, hint:"â†’ e^4", steps:["(1+4/n)^n â†’ e^4"], ans:'e^4', aDefault:1 },
    { id:'18', title:"(vi) lim_{xâ†’0} (1 + 3x)^{2/x}", fExpr:null, hint:"Write exponent 2/x = 6 * (1/(3x)) â‡’ â†’ e^6", steps:["(1+3x)^{2/x} = ((1+3x)^{1/(3x)})^6 â†’ e^6"], ans:'e^6', aDefault:0 }
  ];

  // DOM
  const root = document.getElementById('limits-explorer-2');
  if (!root) return;
  const canvas = root.querySelector('#le2Canvas');
  const ctx = canvas.getContext('2d');
  const problemSelect = root.querySelector('#le2Problem');
  const slider = root.querySelector('#le2Slider');
  const aInput = root.querySelector('#le2A');
  const xVal = root.querySelector('#le2XVal');
  const yVal = root.querySelector('#le2YVal');
  const playBtn = root.querySelector('#le2Play');
  const stepBtn = root.querySelector('#le2Step');
  const revealBtn = root.querySelector('#le2Reveal');
  const hintBtn = root.querySelector('#le2Hint');
  const stepsBox = root.querySelector('#le2StepsBox');
  const problemTitle = root.querySelector('#le2ProblemTitle');
  const sideSelect = root.querySelector('#le2Side');
  const revealAnswer = root.querySelector('#le2RevealAnswer');
  const revealText = root.querySelector('#le2AnswerText');

  // state
  let idx = 0;
  let a = 0;
  let x = parseFloat(slider.value);
  let playing = false;
  let leftX = x - 1.6, rightX = x + 1.6;
  let raf = null;

  // canvas sizing
  function resize() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    draw();
  }
  window.addEventListener('resize', resize);
  resize();

  // populate dropdown
  problems.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = p.title;
    problemSelect.appendChild(opt);
  });

  // helpers
  function safeEvalF(expr, xv, extras={}) {
    try {
      if (!expr) return NaN;
      // allow passing a and p,q,a_val etc via extras
      const func = new Function('x','a','extras','return (' + expr + ')');
      return func(xv, a, extras);
    } catch (e) { return NaN; }
  }

  function setProblem(i) {
    idx = i;
    const p = problems[i];
    problemTitle.textContent = p.title;
    // default a
    a = (typeof p.aDefault !== 'undefined') ? p.aDefault : 0;
    aInput.value = a;
    revealAnswer.hidden = true; revealText.textContent = '';
    stepsBox.hidden = true; stepsBox.innerHTML = '';
    // for cases needing parameters (v and xi) we set placeholders
    // slider start
    slider.value = Math.max(-9, Math.min(9, a - 3));
    x = parseFloat(slider.value);
    leftX = x - 1; rightX = x + 1;
    // special: if problem 5 (a_over_b) or 11 (p2_over_q2) ask user to input parameters via prompt on first load
    if (p.ans === 'a_over_b') {
      // get a and b values from user once (non-blocking prompt ok)
      const aVal = prompt("Enter numeric value for 'a' (for sin(a x)/sin(b x)). Example: 2") || "1";
      const bVal = prompt("Enter numeric value for 'b' (for sin(a x)/sin(b x)). Example: 3") || "1";
      p.a_val = Number(aVal); p.b_val = Number(bVal);
    }
    if (p.ans === 'p2_over_q2') {
      const pVal = prompt("Enter numeric value for 'p' (example: 2)") || "1";
      const qVal = prompt("Enter numeric value for 'q' (example: 3)") || "1";
      p.p_val = Number(pVal); p.q_val = Number(qVal);
    }
    draw();
  }

  function draw() {
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#fbfdff'; ctx.fillRect(0,0,w,h);

    const span = 6;
    const xmin = a - span, xmax = a + span;
    const ymin = -5, ymax = 5;
    function toPx(mx,my){ const px=(mx - xmin)/(xmax-xmin)*w; const py=(1-(my - ymin)/(ymax - ymin))*h; return {x:px,y:py}; }

    // grid
    ctx.strokeStyle = 'rgba(15,23,42,0.06)'; ctx.lineWidth = 1;
    for (let gx=Math.ceil(xmin); gx<=Math.floor(xmax); gx++){ const p = toPx(gx,0); ctx.beginPath(); ctx.moveTo(p.x,0); ctx.lineTo(p.x,h); ctx.stroke(); }

    // x-axis
    const y0 = toPx(a,0).y; ctx.strokeStyle='rgba(15,23,42,0.12)'; ctx.lineWidth=1.4; ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(w,y0); ctx.stroke();

    // vertical a line
    const pa = toPx(a,0); ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(99,102,241,0.18)'; ctx.beginPath(); ctx.moveTo(pa.x,0); ctx.lineTo(pa.x,h); ctx.stroke(); ctx.setLineDash([]);

    // draw function if defined
    const p = problems[idx];
    if (p.fExpr) {
      ctx.strokeStyle = '#2563eb'; ctx.lineWidth=2;
      ctx.beginPath();
      const samples = Math.max(120, Math.floor(w/3));
      for (let i=0;i<=samples;i++){
        const t=i/samples; const mx = xmin + t*(xmax-xmin);
        const my = safeEvalF(p.fExpr, mx, p);
        if (!isFinite(my)) { ctx.moveTo(-100,-100); continue; }
        const pt = toPx(mx,my);
        if (i===0) ctx.moveTo(pt.x,pt.y); else ctx.lineTo(pt.x,pt.y);
      }
      ctx.stroke();
    } else {
      ctx.fillStyle = 'rgba(15,23,42,0.06)'; ctx.font='14px Inter, sans-serif'; ctx.fillText('Symbolic / parameter-based limit â€” use Reveal Steps.', 14, 20);
    }

    // nudge approach points toward a & slider mean
    const mean = parseFloat(slider.value);
    leftX += (Math.min(a-0.0005, mean) - leftX) * 0.08;
    rightX += (Math.max(a+0.0005, mean) - rightX) * 0.08;

    const yL = p.fExpr ? safeEvalF(p.fExpr, leftX, p) : NaN;
    const yR = p.fExpr ? safeEvalF(p.fExpr, rightX, p) : NaN;

    // draw left/right markers
    if (isFinite(yL)) { const pl=toPx(leftX,yL); drawGlow(pl.x,pl.y,20,'rgba(124,58,237,0.08)'); drawDot(pl.x,pl.y,10,'#7c3aed'); }
    if (isFinite(yR)) { const pr=toPx(rightX,yR); drawGlow(pr.x,pr.y,16,'rgba(96,165,250,0.07)'); drawDot(pr.x,pr.y,8,'#2563eb'); }

    const visX = (leftX + rightX)/2;
    const visY = p.fExpr ? safeEvalF(p.fExpr, visX, p) : NaN;
    root.querySelector('#le2XVal').textContent = visX.toFixed(3);
    root.querySelector('#le2YVal').textContent = isFinite(visY) ? visY.toFixed(4) : 'â€”';

    function drawDot(cx,cy,r,fill){ ctx.save(); ctx.beginPath(); ctx.fillStyle=fill; ctx.shadowColor=fill; ctx.shadowBlur=12; ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    function drawGlow(cx,cy,rad,color){ ctx.save(); ctx.fillStyle=color; ctx.beginPath(); ctx.ellipse(cx,cy,rad,rad/2,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  }

  function animate(){
    if (!playing) { if (raf) cancelAnimationFrame(raf); raf=null; return; }
    const cur = parseFloat(slider.value);
    const delta = (a - cur) * 0.02;
    slider.value = (cur + delta).toFixed(3);
    x = parseFloat(slider.value);
    draw();
    raf = requestAnimationFrame(animate);
  }

  // events
  problemSelect.addEventListener('change', ()=> setProblem(parseInt(problemSelect.value)));
  slider.addEventListener('input', ()=> { leftX = parseFloat(slider.value)-0.6; rightX = parseFloat(slider.value)+0.6; draw(); });
  aInput.addEventListener('input', ()=> { a = parseFloat(aInput.value); draw(); });
  sideSelect.addEventListener('change', ()=> draw());

  playBtn.addEventListener('click', ()=> {
    playing = !playing;
    playBtn.textContent = playing ? 'Pause' : 'Play';
    if (playing) animate(); else { if (raf) cancelAnimationFrame(raf); raf=null; }
  });

  stepBtn.addEventListener('click', ()=> {
    leftX += (a - leftX) * 0.28; rightX += (a - rightX) * 0.28;
    slider.value = ((leftX+rightX)/2).toFixed(3); draw();
  });

  hintBtn.addEventListener('click', ()=> {
    stepsBox.hidden = false; stepsBox.innerHTML = '';
    const s = problems[idx].steps || [];
    s.forEach((t,i)=> {
      const d = document.createElement('div'); d.textContent = t; d.style.opacity='0'; d.style.transform='translateX(-6px)';
      d.style.transition = `all 280ms ease ${i*100}ms`; stepsBox.appendChild(d);
      requestAnimationFrame(()=>{ d.style.opacity='1'; d.style.transform='none'; });
    });
  });

  revealBtn.addEventListener('click', ()=> {
    const p = problems[idx];
    revealAnswer.hidden = false;
    if (p.ans === 'a_over_b') {
      const aV = p.a_val || 1, bV = p.b_val || 1; revealText.textContent = String(aV / bV);
    } else if (p.ans === 'p2_over_q2') {
      const P = p.p_val||1, Q = p.q_val||1; revealText.textContent = String((P*P)/(Q*Q));
    } else if (typeof p.ans === 'number') revealText.textContent = String(p.ans);
    else revealText.textContent = (p.ans === null) ? 'Does not exist / ambiguous' : String(p.ans);
  });

  // init
  setProblem(0);
  problemSelect.value = '0';
  draw();

})();


/* ===== Limits Explorer 3 â€” JS (IIFE) =====
   Paste this at the end of <body> or in a .js file included after the HTML.
*/
(function() {
  const problems = {
    p1: {
      title: "f(x)=2x^2 + x - 5",
      f: x => 2*x*x + x - 5,
      cDefault: 1,
      steps: [
        "Polynomials are continuous; left and right limits equal f(c).",
        "Compute f(1) = 2Â·1Â² + 1 âˆ’ 5 = âˆ’2."
      ],
      answer: -2
    },
    p2: {
      title: "f(x)=(x^2 - 9)/(x - 3)",
      f: x => { if (Math.abs(x - 3) < 1e-9) return NaN; return (x*x - 9)/(x - 3); },
      cDefault: 3,
      steps_c3: [
        "Factor numerator: x^2 - 9 = (x - 3)(x + 3).",
        "For x â‰  3 cancel (x - 3) â†’ f(x) = x + 3; limit as x â†’ 3 is 6."
      ],
      steps_cneg3: [
        "If c = -3, denominator â‰  0. Substitute directly: (9 - 9)/(-6) = 0."
      ],
      answer_c3: 6,
      answer_cneg3: 0
    },
    p3: {
      title: "f(x)=|x - 5|",
      f: x => Math.abs(x - 5),
      cDefault: 5,
      steps: [
        "Definition: x<5 â†’ |x-5| = 5 - x; x>5 â†’ |x-5| = x - 5.",
        "Left limit as xâ†’5â»: 5 - x â†’ 0. Right limit as xâ†’5âº: x - 5 â†’ 0. So limit = 0."
      ],
      answer: 0
    }
  };

  // DOM
  const root = document.getElementById('le3-explorer');
  if (!root) return;
  const canvas = root.querySelector('#le3Canvas');
  const ctx = canvas.getContext('2d');
  const selProblem = root.querySelector('#le3Problem');
  const selSide = root.querySelector('#le3Side');
  const slider = root.querySelector('#le3Slider');
  const aInput = root.querySelector('#le3A');
  const titleEl = root.querySelector('#le3ProblemTitle');
  const xValEl = root.querySelector('#le3XVal');
  const yValEl = root.querySelector('#le3YVal');
  const playBtn = root.querySelector('#le3Play');
  const stepBtn = root.querySelector('#le3Step');
  const revealBtn = root.querySelector('#le3Reveal');
  const hintBtn = root.querySelector('#le3Hint');
  const stepsBox = root.querySelector('#le3StepsBox');
  const revealBox = root.querySelector('#le3RevealAnswer');
  const revealText = root.querySelector('#le3AnswerText');

  // state
  let key = selProblem.value || 'p1';
  let a = problems[key].cDefault;
  aInput.value = a;
  let leftX = parseFloat(slider.value) - 1.2;
  let rightX = parseFloat(slider.value) + 1.2;
  let playing = false;
  let raf = null;

  // canvas sizing (CSS pixel aware)
  function fit() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', fit);
  fit();

  // render dropdown initial titles (already in HTML, but ensure title shown)
  function setProblem(k) {
    key = k;
    const p = problems[k];
    titleEl.textContent = p.title;
    a = (p.cDefault !== undefined) ? p.cDefault : 0;
    aInput.value = a;
    revealBox.hidden = true;
    revealText.textContent = '';
    stepsBox.hidden = true; stepsBox.innerHTML = '';
    // set slider to a sensible place
    slider.value = Math.max(-8, Math.min(8, a - 3));
    leftX = parseFloat(slider.value) - 1.2;
    rightX = parseFloat(slider.value) + 1.2;
    draw();
  }

  function draw() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fbfdff'; ctx.fillRect(0,0,w,h);

    const span = 6;
    const xmin = a - span, xmax = a + span;
    const ymin = -6, ymax = 6;
    function toPx(mx,my){ const px=(mx-xmin)/(xmax-xmin)*w; const py=(1-(my-ymin)/(ymax-ymin))*h; return {x:px,y:py}; }

    // grid
    ctx.strokeStyle = 'rgba(15,23,42,0.06)'; ctx.lineWidth = 1;
    for (let gx=Math.ceil(xmin); gx<=Math.floor(xmax); gx++){
      const p = toPx(gx,0); ctx.beginPath(); ctx.moveTo(p.x,0); ctx.lineTo(p.x,h); ctx.stroke();
    }

    // axis
    const y0 = toPx(a,0).y; ctx.strokeStyle='rgba(15,23,42,0.12)'; ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(w,y0); ctx.stroke();

    // vertical at a
    const pa = toPx(a,0); ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(99,102,241,0.18)'; ctx.beginPath(); ctx.moveTo(pa.x,0); ctx.lineTo(pa.x,h); ctx.stroke(); ctx.setLineDash([]);

    // draw function curve if possible
    const p = problems[key];
    if (p && p.f) {
      ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2;
      ctx.beginPath();
      const samples = Math.max(120, Math.floor(w/3));
      for (let i=0;i<=samples;i++){
        const t = i/samples; const mx = xmin + t*(xmax-xmin);
        let my = p.f(mx);
        if (!isFinite(my) || Math.abs(my) > 1e4) { ctx.moveTo(-10,-10); continue; }
        const pt = toPx(mx,my);
        if (i===0) ctx.moveTo(pt.x,pt.y); else ctx.lineTo(pt.x,pt.y);
      }
      ctx.stroke();
    } else {
      ctx.fillStyle = 'rgba(15,23,42,0.06)'; ctx.font='13px sans-serif'; ctx.fillText('Use Reveal Steps/Limit for symbolic cases', 12, 18);
    }

    // approach points â€” nudge toward slider mean or toward a depending on side
    const side = selSide.value;
    const mean = parseFloat(slider.value);
    leftX += ((side==='right' ? a + 0.001 : Math.min(a - 0.0001, mean)) - leftX) * 0.08;
    rightX += ((side==='left' ? a - 0.001 : Math.max(a + 0.0001, mean)) - rightX) * 0.08;

    const yL = (p && p.f) ? p.f(leftX) : NaN;
    const yR = (p && p.f) ? p.f(rightX) : NaN;

    if (isFinite(yL)) { const pl = toPx(leftX,yL); drawGlow(pl.x,pl.y,20,'rgba(124,58,237,0.08)'); drawDot(pl.x,pl.y,10,'#7c3aed'); }
    if (isFinite(yR)) { const pr = toPx(rightX,yR); drawGlow(pr.x,pr.y,16,'rgba(96,165,250,0.07)'); drawDot(pr.x,pr.y,8,'#2563eb'); }

    const visX = (leftX + rightX)/2;
    const visY = (p && p.f) ? p.f(visX) : NaN;
    root.querySelector('#le3XVal').textContent = visX.toFixed(3);
    root.querySelector('#le3YVal').textContent = isFinite(visY) ? visY.toFixed(4) : 'â€”';

    function drawDot(cx,cy,r,color){ ctx.save(); ctx.beginPath(); ctx.fillStyle=color; ctx.shadowColor=color; ctx.shadowBlur=12; ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    function drawGlow(cx,cy,rad,color){ ctx.save(); ctx.fillStyle=color; ctx.beginPath(); ctx.ellipse(cx,cy,rad,rad/2,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  }

  function animate() {
    if (!playing) { if (raf) cancelAnimationFrame(raf); raf = null; return; }
    const cur = parseFloat(slider.value);
    const delta = (a - cur) * 0.02;
    slider.value = (cur + delta).toFixed(3);
    draw();
    raf = requestAnimationFrame(animate);
  }

  // UI events
  selProblem.addEventListener('change', ()=> setProblem(selProblem.value));
  slider.addEventListener('input', ()=> { const val = parseFloat(slider.value); leftX = val - 0.6; rightX = val + 0.6; draw(); });
  aInput.addEventListener('input', ()=> { a = Number(aInput.value); draw(); });
  selSide.addEventListener('change', ()=> draw());

  playBtn.addEventListener('click', ()=> {
    playing = !playing;
    playBtn.textContent = playing ? 'Pause' : 'Play';
    if (playing) animate(); else { if (raf) cancelAnimationFrame(raf); raf=null; }
  });

  stepBtn.addEventListener('click', ()=> {
    leftX += (a - leftX) * 0.28; rightX += (a - rightX) * 0.28;
    slider.value = ((leftX + rightX)/2).toFixed(3);
    draw();
  });

  hintBtn.addEventListener('click', ()=> {
    stepsBox.hidden = false; stepsBox.innerHTML = '';
    const p = problems[key];
    let list = p.steps || [];
    if (key === 'p2') {
      const cVal = Number(aInput.value);
      if (Math.abs(cVal - 3) < 1e-6) list = p.steps_c3;
      if (Math.abs(cVal + 3) < 1e-6) list = p.steps_cneg3;
    }
    list.forEach((s,i)=> {
      const d = document.createElement('div'); d.textContent = s; d.style.opacity = '0'; d.style.transform = 'translateX(-6px)'; d.style.transition = `all 260ms ease ${i*90}ms`;
      stepsBox.appendChild(d);
      requestAnimationFrame(()=>{ d.style.opacity='1'; d.style.transform='none'; });
    });
  });

  revealBtn.addEventListener('click', ()=> {
    revealBox.hidden = false;
    const p = problems[key];
    const cVal = Number(aInput.value);
    if (key === 'p2') {
      if (Math.abs(cVal - 3) < 1e-6) revealText.textContent = String(p.answer_c3);
      else if (Math.abs(cVal + 3) < 1e-6) revealText.textContent = String(p.answer_cneg3);
      else revealText.textContent = String((cVal*cVal - 9)/(cVal - 3));
    } else {
      revealText.textContent = (p.answer !== undefined) ? String(p.answer) : 'â€”';
    }
  });

  function setProblem(k) {
    setTimeout(()=> { // slight delay for UI cohesion
      key = k; const p = problems[k];
      titleEl.textContent = p.title;
      a = (p.cDefault !== undefined) ? p.cDefault : 0;
      aInput.value = a;
      stepsBox.hidden = true; stepsBox.innerHTML = '';
      revealBox.hidden = true; revealText.textContent = '';
      slider.value = Math.max(-8, Math.min(8, a - 3));
      leftX = parseFloat(slider.value) - 1.2;
      rightX = parseFloat(slider.value) + 1.2;
      draw();
    }, 30);
  }

  // initialize
  setProblem(selProblem.value || 'p1');
  fit();
})();



  // ===== Structured question objects (p2-style) =====
  const structuredQuestions = [
    // p1 (example)
    {
      title: `\\( f(x)=\\begin{cases}2x+5,&x\\le2\\\\4x+1,&x>2\\end{cases} \\) â€” check at \\(c=2\\)`,
      f: x => { if (x <= 2 + 1e-12) return 2*x + 5; else return 4*x + 1; },
      cDefault: 2,
      steps_c2: [
        "Compute left-hand: for x < 2 use 2x+5 â†’ at xâ†’2â» gives 2(2)+5 = 9.",
        "Compute right-hand: for x > 2 use 4x+1 â†’ at xâ†’2âº gives 4(2)+1 = 9.",
        "f(2) is taken from x â‰¤ 2 rule â†’ f(2)=9. All equal â†’ continuous."
      ],
      answer_c2: "Continuous"
    },

    // p2 (the one you gave)
    {
      title: `\\( f(x)=\\dfrac{x^2 - 9}{x - 3} \\) â€” check at \\(c=3\\) and \\(c=-3\\)`,
      f: x => { if (Math.abs(x - 3) < 1e-12) return NaN; return (x*x - 9)/(x - 3); },
      cDefault: 3,
      steps_c3: [
        "Factor numerator: x^2 - 9 = (x - 3)(x + 3).",
        "For x â‰  3 cancel (x - 3) â†’ f(x) simplifies to x + 3. So limit as x â†’ 3 is 6.",
        "Original function is not defined at x=3 (hole), but the limit exists (removable). If f(3) is undefined â†’ discontinuous; if defined as 6 â†’ continuous."
      ],
      steps_cneg3: [
        "At c = -3 the denominator is nonzero (âˆ’3 âˆ’ 3 = âˆ’6). Plugging in: (9 âˆ’ 9)/(âˆ’6) = 0. So continuous at x = âˆ’3."
      ],
      answer_c3: 6,
      answer_cneg3: 0
    },

    // p3 (piecewise with constant at x=1)
    {
      title: `\\( f(x)=\\begin{cases}3x-1,&x<1\\\\4,&x=1\\\\2x,&x>1\\end{cases} \\) â€” check at \\(c=1\\)`,
      f: x => { if (x < 1 - 1e-12) return 3*x - 1; if (Math.abs(x-1) < 1e-12) return 4; return 2*x; },
      cDefault: 1,
      steps_c1: [
        "Left-hand limit as x â†’ 1â»: 3(1) - 1 = 2.",
        "Right-hand limit as x â†’ 1âº: 2(1) = 2.",
        "Function value f(1) = 4. Limits agree but f(1) â‰  limit â†’ jump (removable? actually a point-value mismatch) = discontinuous."
      ],
      answer_c1: 2
    },

    // p4 (three-piece piecewise requiring left/right check at -2 and 2)
    {
      title: `\\( f(x)=\\begin{cases}3x,&x\\le-2\\\\x^2-1,&-2<x<2\\\\3,&x\\ge2\\end{cases} \\) â€” check at \\(c=-2\\) and \\(c=2\\)`,
      f: x => { if (x <= -2 + 1e-12) return 3*x; if (x < 2 - 1e-12) return x*x - 1; return 3; },
      cDefault: -2,
      steps_c2: [
        "Left-hand limit at x â†’ 2â»: use xÂ² âˆ’ 1 â†’ 2Â² âˆ’ 1 = 3.",
        "Right-hand (x â†’ 2âº): from 'x â‰¥ 2' rule â†’ f(2) = 3. Both equal â†’ continuous at 2."
      ],
      steps_cneg2: [
        "Left-hand limit at x â†’ âˆ’2â»: use 3x â†’ 3(âˆ’2) = âˆ’6.",
        "Right-hand limit at x â†’ âˆ’2âº: use xÂ² âˆ’ 1 â†’ (âˆ’2)Â² âˆ’ 1 = 3. Not equal â†’ discontinuous at âˆ’2."
      ]
    }
  ];

  // ===== utilities =====
  const eps = 1e-6; // small delta for numeric check

  let structIndex = 0;

  // get DOM elements
  const pqTitle = document.getElementById('pqTitle');
  const pqDisplay = document.getElementById('pqDisplay');
  const cInput = document.getElementById('cInput');
  const structuredResult = document.getElementById('structuredResult');
  const structuredSteps = document.getElementById('structuredSteps');

  function renderStructured() {
    const q = structuredQuestions[structIndex];
    pqTitle.innerText = `Question ${structIndex + 1} of ${structuredQuestions.length}`;
    pqDisplay.innerHTML = q.title.replace(/\\\\/g, '\\\\'); // keep latex escapes
    cInput.value = q.cDefault;
    structuredResult.innerHTML = '';
    structuredSteps.innerHTML = '';
    // reset flower bloom lightly
    const flower = document.getElementById('flower' + String.fromCharCode(65 + structIndex));
    if (flower) { flower.textContent = 'ğŸŒ±'; flower.classList.remove('bloom'); }
    if (window.MathJax) MathJax.typeset();
  }

  // compute numeric one-sided values safely (returns {value, ok})
  function safeEval(f, x) {
    try {
      const v = f(x);
      if (typeof v === 'number' && !Number.isFinite(v)) return { ok:false, value: NaN };
      return { ok: true, value: v };
    } catch (e) {
      return { ok: false, value: NaN };
    }
  }

  function approxLeftRight(f, c) {
    // pick decreasing deltas to get stable approx
    const deltas = [1e-3, 1e-4, 1e-5];
    let left = NaN, right = NaN;
    for (let d of deltas) {
      const L = safeEval(f, c - d);
      const R = safeEval(f, c + d);
      if (L.ok && R.ok) { left = L.value; right = R.value; break; }
    }
    return { left, right };
  }

  function showExplanationForC(q, c) {
    // look for steps_c<value> or steps_cneg<abs(value)> variant
    const sanitized = (c % 1 === 0) ? String(c) : String(c).replace('.', 'dot');
    // try keys: steps_c3, steps_cneg3 (for negative c)
    const keyExact = 'steps_c' + (c < 0 ? 'neg' + Math.abs(c) : String(c));
    const keyPlain = 'steps_c' + String(c);
    // custom search: prefer exact numeric matches from object keys:
    for (let k of Object.keys(q)) {
      if (k.startsWith('steps_c')) {
        // build readable key forms to compare: steps_c3, steps_cneg3, steps_c-2 etc
        if (k.toLowerCase().includes(String(c).replace('-', 'neg').replace('.', ''))) {
          return q[k].map(s => `<div class="note-box">${s}</div>`).join('<br>');
        }
      }
    }
    // fallback: try conventional property names used earlier
    if (q['steps_c' + c]) return q['steps_c' + c].map(s => `<div class="note-box">${s}</div>`).join('<br>');
    if (c < 0 && q['steps_cneg' + Math.abs(c)]) return q['steps_cneg' + Math.abs(c)].map(s => `<div class="note-box">${s}</div>`).join('<br>');
    // last fallback (auto explanation)
    return `<div class="note-box">No saved steps for c=${c}. I checked numerically and compared one-sided limits and f(c) (if defined).</div>`;
  }

  function checkAtC() {
    const q = structuredQuestions[structIndex];
    const c = parseFloat(cInput.value);
    structuredSteps.innerHTML = ''; // clear previous steps
    if (Number.isNaN(c)) {
      structuredResult.innerHTML = `<span class="soft-bad">Please enter a valid number for c.</span>`;
      return;
    }

    // numeric left/right
    const approx = approxLeftRight(q.f, c);
    const left = approx.left, right = approx.right;
    // evaluate f(c) directly
    const atc = safeEval(q.f, c);

    // Build gentle message
    let html = '';
    html += `<div class="note-box">`;
    html += `<div><strong>Left approx (xâ†’${c}â»):</strong> ${Number.isFinite(left) ? left : 'not defined / NaN'}</div>`;
    html += `<div><strong>Right approx (xâ†’${c}âº):</strong> ${Number.isFinite(right) ? right : 'not defined / NaN'}</div>`;
    html += `<div><strong>f(${c}) (direct):</strong> ${ (atc.ok && Number.isFinite(atc.value)) ? atc.value : 'not defined / NaN' }</div>`;
    html += `</div>`;

    // Decide continuity gently
    let verdict = '';
    if (!Number.isFinite(left) || !Number.isFinite(right)) {
      // if one side undefined numeric â†’ we check if both are NaN (both undefined) or mixed
      if (!Number.isFinite(left) && !Number.isFinite(right)) {
        verdict = `<div class="soft-bad">Both sides undefined numerically â€” check symbolic steps.</div>`;
      } else {
        verdict = `<div class="soft-bad">One side undefined â†’ limits don't match â†’ Discontinuous.</div>`;
      }
    } else {
      // both sides finite: compare approximately
      if (Math.abs(left - right) < 1e-4) {
        // limit exists
        if (atc.ok && Number.isFinite(atc.value) && Math.abs(atc.value - left) < 1e-4) {
          verdict = `<div class="soft-ok">All equal â†’ <strong>Continuous at x = ${c}</strong></div>`;
        } else {
          verdict = `<div class="soft-bad">Limit exists but f(${c}) â‰  limit (or f(${c}) undefined) â†’ <strong>Discontinuous</strong> (removable if f can be redefined).</div>`;
        }
      } else {
        verdict = `<div class="soft-bad">Left â‰  Right â†’ <strong>Discontinuous</strong> (jump / essential).</div>`;
      }
    }

    structuredResult.innerHTML = html + '<br>' + verdict;

    // show stored human steps if available
    const stepsHtml = showExplanationForC(q, c);
    structuredSteps.innerHTML = `<h4 style="margin-bottom:6px;">Notes</h4>` + stepsHtml;

    // bloom the flower gently if correct (continuity)
    const flower = document.getElementById('flower' + String.fromCharCode(65 + structIndex));
    if (flower) {
      if (verdict.includes('Continuous')) { flower.textContent = 'ğŸŒ¸'; flower.classList.add('bloom'); }
      else { flower.textContent = 'ğŸ‚'; flower.classList.remove('bloom'); }
    }

    if (window.MathJax) MathJax.typeset();
  }

  function showSteps() {
    // just trigger the steps panel for current c
    const q = structuredQuestions[structIndex];
    const c = parseFloat(cInput.value);
    structuredSteps.innerHTML = showExplanationForC(q, c);
    if (window.MathJax) MathJax.typeset();
  }

  function nextStructured() {
    structIndex = (structIndex + 1) % structuredQuestions.length;
    renderStructured();
  }

  // initial render
  renderStructured();

// Continuity Tile Puzzle JS (drag-and-drop, no voice)
document.addEventListener("DOMContentLoaded", () => {
  // Utility: create tiles array for each problem dynamically
  function makeTiles(containerId, values) {
    const cont = document.getElementById(containerId);
    cont.innerHTML = "";
    values.forEach(v => {
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.draggable = true;
      tile.textContent = v;
      tile.dataset.value = v;
      tile.addEventListener("dragstart", tileDragStart);
      tile.addEventListener("dragend", tileDragEnd); // ensure cleanup
      cont.appendChild(tile);
    });
  }

  // drag handlers
  let dragged = null;
  function tileDragStart(e) {
    dragged = e.target;
    e.dataTransfer.setData("text/plain", e.target.dataset.value);
    setTimeout(()=> e.target.classList.add("hidden"), 0);
  }
  function tileDragEnd(e) {
    if (e.target && e.target.classList) e.target.classList.remove("hidden");
    dragged = null;
  }

  // dropzones
  const dropzones = document.querySelectorAll(".dropzone");
  dropzones.forEach(z => {
    z.addEventListener("dragover", e => e.preventDefault());
    z.addEventListener("drop", e => {
      e.preventDefault();
      const v = e.dataTransfer.getData("text/plain");
      // accept only one tile per slot: replace if existing tile present (return it)
      const existing = z.querySelector(".tile");
      if (existing) {
        // move existing back to tiles area
        const parentTiles = z.closest(".puzzle").querySelector(".tiles");
        parentTiles.appendChild(existing);
      }
      // find tile element (either dragged or existing in tiles)
      let tileEl = dragged;
      if (!tileEl) {
        // fallback: search by dataset.value inside puzzle tiles
        const parentTiles = z.closest(".puzzle").querySelector(".tiles");
        tileEl = Array.from(parentTiles.querySelectorAll(".tile")).find(t => t.dataset.value === v);
      }
      if (tileEl) {
        z.appendChild(tileEl);
        tileEl.style.cursor = "default";
      }
      // mark filled
      z.classList.add("filled");
    });
  });

  // Remove tile when clicked in slot (send back to tiles)
  document.addEventListener("click", e => {
    if (e.target.classList.contains("tile")) {
      const parent = e.target.parentElement;
      if (parent.classList.contains("dropzone")) {
        const puzzleTiles = parent.closest(".puzzle").querySelector(".tiles");
        puzzleTiles.appendChild(e.target);
        parent.classList.remove("filled", "correct", "wrong");
      }
    }
  });

  // tile dragend cleanup (global)
  document.addEventListener("dragend", e => {
    if (e.target && e.target.classList) e.target.classList.remove("hidden");
  });

  // Problem-specific setup
  // PROB 1: left limit for x<3 is m*3 => 3m ; right limit for x>3 is -2*3+9 = -6+9 = 3
  // So left = 3m, right = 3. For continuity at 3 we need 3m = 3 and n = 3 -> m = 1, n = 3
  // We'll provide tiles around these values for gentle exploration
  makeTiles("tiles1", ["-2","-1","0","1","2","3","4"]);
  // PROB 2: left limit = 3m ; right/value at 3 = 3^2 = 9 -> so m = 3
  makeTiles("tiles2", ["0","1","2","3","4","5","9"]);

  // Check / hint / reset handlers
  document.querySelectorAll(".btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const action = btn.dataset.action;
      const prob = btn.dataset.prob;
      if (action === "check") checkPuzzle(parseInt(prob));
      if (action === "hint") hintPuzzle(parseInt(prob));
      if (action === "reset") resetPuzzle(parseInt(prob));
    });
  });

  function readSlotValue(puzzleId, slotName) {
    const slot = document.querySelector(`#${puzzleId} .dropzone[data-slot="${slotName}"]`);
    if (!slot) return null;
    const tile = slot.querySelector(".tile");
    return tile ? Number(tile.dataset.value) : null;
  }

  function checkPuzzle(prob) {
    if (prob === 1) {
      const puzzleEl = document.getElementById("tileProb1");
      const left = readSlotValue("tileProb1","p1_left");
      const val  = readSlotValue("tileProb1","p1_value");
      const right= readSlotValue("tileProb1","p1_right");
      const feedback = document.getElementById("feedback1");

      // expected: left = 3m, right = 3, so m must be 1 and n must be 3
      const correctLeft = 3;
      const correctVal = 3;
      const correctRight = 3;

      // clear classes
      puzzleEl.querySelectorAll(".dropzone").forEach(s => s.classList.remove("correct","wrong"));

      let ok = true;
      // left check
      if (left === null) { ok = false; puzzleEl.querySelector('[data-slot="p1_left"]').classList.add("wrong"); }
      else if (left === correctLeft) puzzleEl.querySelector('[data-slot="p1_left"]').classList.add("correct");
      else { ok = false; puzzleEl.querySelector('[data-slot="p1_left"]').classList.add("wrong"); }

      // value check
      if (val === null) { ok = false; puzzleEl.querySelector('[data-slot="p1_value"]').classList.add("wrong"); }
      else if (val === correctVal) puzzleEl.querySelector('[data-slot="p1_value"]').classList.add("correct");
      else { ok = false; puzzleEl.querySelector('[data-slot="p1_value"]').classList.add("wrong"); }

      // right check
      if (right === null) { ok = false; puzzleEl.querySelector('[data-slot="p1_right"]').classList.add("wrong"); }
      else if (right === correctRight) puzzleEl.querySelector('[data-slot="p1_right"]').classList.add("correct");
      else { ok = false; puzzleEl.querySelector('[data-slot="p1_right"]').classList.add("wrong"); }

      if (ok) {
        feedback.textContent = "Nice! All matched â€” function is continuous at x = 3 (m = 1, n = 3).";
      } else {
        feedback.textContent = "Not yet â€” try different tiles. Hint available.";
      }
    }

    if (prob === 2) {
      const puzzleEl = document.getElementById("tileProb2");
      const left = readSlotValue("tileProb2","p2_left");
      const right= readSlotValue("tileProb2","p2_right");
      const feedback = document.getElementById("feedback2");

      // expected: left = 3m ; right/value = 9 => so m = 3
      const correctLeft = 9;
      const correctRight = 9;

      puzzleEl.querySelectorAll(".dropzone").forEach(s => s.classList.remove("correct","wrong"));

      let ok = true;
      if (left === null) { ok = false; puzzleEl.querySelector('[data-slot="p2_left"]').classList.add("wrong"); }
      else if (left === correctLeft) puzzleEl.querySelector('[data-slot="p2_left"]').classList.add("correct");
      else { ok = false; puzzleEl.querySelector('[data-slot="p2_left"]').classList.add("wrong"); }

      if (right === null) { ok = false; puzzleEl.querySelector('[data-slot="p2_right"]').classList.add("wrong"); }
      else if (right === correctRight) puzzleEl.querySelector('[data-slot="p2_right"]').classList.add("correct");
      else { ok = false; puzzleEl.querySelector('[data-slot="p2_right"]').classList.add("wrong"); }

      if (ok) {
        feedback.textContent = "Great! Limits match â€” continuous at x = 3 (m = 3).";
      } else {
        feedback.textContent = "Try again â€” the left and right should both be 9.";
      }
    }
  }

  function hintPuzzle(prob) {
    if (prob === 1) {
      const box = document.getElementById("feedback1");
      box.innerHTML = "Hint: Left limit = 3Â·m (because x â†’ 3â»). Right limit = evaluate -2x+9 at x=3 â†’ 3. For continuity left = right = value, so 3m = 3 and n = 3.";
    }
    if (prob === 2) {
      const box = document.getElementById("feedback2");
      box.innerHTML = "Hint: Right/value at 3 uses xÂ² â†’ 3Â² = 9. So left = 3m should equal 9 â†’ m = 3.";
    }
  }

  function resetPuzzle(prob) {
    if (prob === 1) {
      // move tiles back
      const t = document.getElementById("tiles1");
      const slots = document.querySelectorAll("#tileProb1 .dropzone");
      slots.forEach(s => {
        const tile = s.querySelector(".tile");
        if (tile) t.appendChild(tile);
        s.classList.remove("filled","correct","wrong");
      });
      document.getElementById("feedback1").textContent = "";
    }
    if (prob === 2) {
      const t = document.getElementById("tiles2");
      const slots = document.querySelectorAll("#tileProb2 .dropzone");
      slots.forEach(s => {
        const tile = s.querySelector(".tile");
        if (tile) t.appendChild(tile);
        s.classList.remove("filled","correct","wrong");
      });
      document.getElementById("feedback2").textContent = "";
    }
  }

  // small fix: create tile containers initially if not present
  if (!document.getElementById("tiles1").children.length) {
    // tiles already created above by makeTiles
  }

  // safety: prevent text selection while dragging
  document.addEventListener("selectstart", e => {
    if (e.target.classList && e.target.classList.contains("tile")) e.preventDefault();
  });
});

// Rationalize Relay logic (HTML-only, no voice)
document.addEventListener("DOMContentLoaded", () => {
  // DOM refs
  const xInput = document.getElementById("xInput");
  const xRange = document.getElementById("xRange");
  const exprVal = document.getElementById("exprVal");
  const numVal = document.getElementById("numVal");
  const denVal = document.getElementById("denVal");
  const approachBtn = document.getElementById("approachBtn");
  const approachSeriesBtn = document.getElementById("approachSeriesBtn");
  const seriesBox = document.getElementById("seriesBox");

  const showStepsBtn = document.getElementById("showStepsBtn");
  const hideStepsBtn = document.getElementById("hideStepsBtn");
  const stepsBox = document.getElementById("stepsBox");

  const kInput = document.getElementById("kInput");
  const checkK = document.getElementById("checkK");
  const hintK = document.getElementById("hintK");
  const revealK = document.getElementById("revealK");
  const kFeedback = document.getElementById("kFeedback");
  const kSuggestion = document.getElementById("kSuggestion");

  const confettiArea = document.getElementById("confettiArea");

  // Evaluate expression safely
  function evalExpr(x) {
    // numerator = sqrt(2x+5) - sqrt(x+7)
    const a = 2 * x + 5;
    const b = x + 7;
    if (a < 0 || b < 0) return { ok:false, reason: "domain" };
    const num = Math.sqrt(a) - Math.sqrt(b);
    const den = x - 2;
    const val = num / den;
    return { ok: true, val, num, den };
  }

  // sync range and number input
  xRange.addEventListener("input", () => { xInput.value = xRange.value; });
  xInput.addEventListener("input", () => { xRange.value = xInput.value; });

  function renderForX(x) {
    const r = evalExpr(x);
    if (!r.ok) {
      exprVal.textContent = "not defined (domain)";
      numVal.textContent = "â€”";
      denVal.textContent = "â€”";
    } else {
      exprVal.textContent = Number(r.val.toFixed(6));
      numVal.textContent = Number(r.num.toFixed(6));
      denVal.textContent = Number(r.den.toFixed(6));
    }
  }

  approachBtn.addEventListener("click", () => {
    const x = parseFloat(xInput.value);
    renderForX(x);
  });

  // Try a few x values approaching 2 from both sides
  approachSeriesBtn.addEventListener("click", () => {
    const xs = [1.9, 1.99, 1.999, 2.001, 2.01, 2.1];
    let html = "<strong>Values approaching x=2:</strong><br>";
    xs.forEach(xx => {
      const r = evalExpr(xx);
      const v = r.ok ? Number(r.val.toFixed(6)) : "NaN";
      html += `x=${xx} â†’ ${v}<br>`;
    });
    seriesBox.style.display = "block";
    seriesBox.innerHTML = html + "<em>They should get close to the same number from both sides.</em>";
  });

  // Show algebraic rationalization steps
  showStepsBtn.addEventListener("click", () => {
    const stepsHtml = [
      "We have: (âˆš(2x+5) âˆ’ âˆš(x+7)) / (x âˆ’ 2). Substitute x = 2 gives 0/0, so rationalize.",
      "Multiply numerator & denominator by (âˆš(2x+5) + âˆš(x+7)).",
      "Numerator becomes (2x+5) âˆ’ (x+7) = x âˆ’ 2.",
      "Denominator becomes (xâˆ’2)(âˆš(2x+5) + âˆš(x+7)). Cancel (xâˆ’2).",
      "Result: 1 / (âˆš(2x+5) + âˆš(x+7)).",
      "Now let x â†’ 2: denominator â†’ âˆš9 + âˆš9 = 3 + 3 = 6 â†’ limit = 1/6."
    ];
    stepsBox.innerHTML = "<div style='font-weight:700; margin-bottom:6px'>Rationalization Steps</div>";
    stepsHtml.forEach((s,i) => {
      stepsBox.innerHTML += `<div style="margin-bottom:6px">${i+1}. ${s}</div>`;
    });
    // show the final numeric as suggestion
    kSuggestion.style.display = "none";
  });

  hideStepsBtn.addEventListener("click", () => {
    stepsBox.innerHTML = "Click <strong>Show Steps</strong> to see how to simplify algebraically.";
  });

  // check k
  function showConfetti() {
    // generate 18 confetti pieces
    for (let i=0;i<18;i++){
      const c = document.createElement("div");
      c.className = "confetti";
      c.style.left = (10 + Math.random()*80) + "%";
      c.style.background = ['#ff595e','#ffca3a','#8ac926','#1982c4','#6a4c93'][Math.floor(Math.random()*5)];
      confettiArea.appendChild(c);
      // remove after animation
      setTimeout(()=> c.remove(), 1400);
    }
  }

  checkK.addEventListener("click", () => {
    const k = parseFloat(kInput.value);
    if (isNaN(k)) {
      kFeedback.textContent = "Please enter a numeric value for k.";
      return;
    }
    const correct = 1/6;
    const diff = Math.abs(k - correct);
    if (diff < 1e-6 || Math.abs(k - correct) < 0.0005) {
      kFeedback.textContent = "ğŸŒŸ Correct! The limit is 1/6, so k = 1/6 makes f continuous at x = 2.";
      kFeedback.style.color = "#0b6623";
      kSuggestion.style.display = "none";
      showConfetti();
    } else {
      kFeedback.textContent = "Not quite â€” here are steps to check and a suggested value.";
      kFeedback.style.color = "#9b2b2b";
      // show suggestion and small algebra
      kSuggestion.style.display = "block";
      kSuggestion.innerHTML = "<strong>Quick check:</strong><br>" +
        "After rationalizing you get 1 / (âˆš(2x+5) + âˆš(x+7)).<br>" +
        "Plug x = 2 â†’ 1 / (3 + 3) = 1/6 â‰ˆ 0.1666667.<br>" +
        `Your entry: ${k}. Try setting k = 0.1667 (or 1/6).`;
    }
  });

  hintK.addEventListener("click", () => {
    stepsBox.innerHTML = "<div style='font-weight:700; margin-bottom:6px'>Hint</div>"
      + "<div>Try multiplying numerator and denominator by (âˆš(2x+5) + âˆš(x+7)). You will get (x-2) on top which cancels.</div>";
    kSuggestion.style.display = "none";
  });

  revealK.addEventListener("click", () => {
    kInput.value = (1/6).toFixed(6);
    kFeedback.textContent = "Revealed: k = 1/6";
    kFeedback.style.color = "#0b6623";
    kSuggestion.style.display = "none";
    showConfetti();
  });

  // initial render
  renderForX(parseFloat(xInput.value));
});

// ğŸ¨ Graph Explorer logic
document.addEventListener("DOMContentLoaded", () => {
  const canvas = document.getElementById("graphCanvas");
  const ctx = canvas.getContext("2d");
  const hintBox = document.getElementById("hintBox");
  const hintBtn = document.getElementById("hintBtn");
  const tabs = document.querySelectorAll(".tab-btn");

  // coordinate system scaling
  const width = canvas.width;
  const height = canvas.height;
  const scaleX = 40; // pixels per unit
  const scaleY = 40;

  // draw axes
  function drawAxes() {
    ctx.clearRect(0,0,width,height);
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#888";
    ctx.beginPath();
    // x-axis
    ctx.moveTo(0, height/2);
    ctx.lineTo(width, height/2);
    // y-axis
    ctx.moveTo(width/2, 0);
    ctx.lineTo(width/2, height);
    ctx.stroke();
  }

  // helper: convert coords to canvas
  function toCanvas(x, y) {
    return [
      width/2 + x * scaleX,
      height/2 - y * scaleY
    ];
  }

  // graph drawing functions
  const graphs = {
    eq1: {
      hint: "This is a circle centered at origin with radius 3.",
      draw: function() {
        drawAxes();
        ctx.strokeStyle = "#3b82f6";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let theta = 0; theta <= Math.PI*2; theta += 0.01) {
          const x = 3 * Math.cos(theta);
          const y = 3 * Math.sin(theta);
          const [cx, cy] = toCanvas(x, y);
          if (theta === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }
    },
    eq2: {
      hint: "An ellipse centered at origin â€” a stretched circle! Semi-major axis = 4 (x-direction), semi-minor = 2 (y-direction).",
      draw: function() {
        drawAxes();
        ctx.strokeStyle = "#f97316";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let t = 0; t <= Math.PI*2; t += 0.01) {
          const x = 4 * Math.cos(t);
          const y = 2 * Math.sin(t);
          const [cx, cy] = toCanvas(x, y);
          if (t === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }
    },
    eq3: {
      hint: "This is an exponential curve â€” starts small, rises rapidly! (e^(2x)) grows faster than e^x.",
      draw: function() {
        drawAxes();
        ctx.strokeStyle = "#22c55e";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = -2; x <= 2; x += 0.02) {
          const y = Math.exp(2 * x);
          const [cx, cy] = toCanvas(x, y/10); // scale y down for display
          if (x === -2) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }
    },
    eq4: {
      hint: "Another exponential curve â€” base 3, so it rises even faster than e^(2x)!",
      draw: function() {
        drawAxes();
        ctx.strokeStyle = "#a855f7";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = -2; x <= 2; x += 0.02) {
          const y = Math.pow(3, x);
          const [cx, cy] = toCanvas(x, y/4); // scaled for visibility
          if (x === -2) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }
    }
  };

  // animation helper
  function animateGraph(drawFunc) {
    drawAxes();
    let progress = 0;
    const interval = setInterval(() => {
      progress += 0.04;
      drawAxes();
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, width*progress/2, height);
      ctx.clip();
      drawFunc();
      ctx.restore();
      if (progress >= 2) clearInterval(interval);
    }, 40);
  }

  // active equation
  let currentEq = "eq1";
  graphs[currentEq].draw();
  hintBox.textContent = graphs[currentEq].hint;

  // handle tab switch
  tabs.forEach(tab => {
    tab.addEventListener("click", () => {
      tabs.forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      currentEq = tab.dataset.eq;
      animateGraph(graphs[currentEq].draw);
      hintBox.textContent = "";
    });
  });

  // show hint
  hintBtn.addEventListener("click", () => {
    hintBox.textContent = graphs[currentEq].hint;
  });
});

// ğŸ¡ Parametric Playground logic
document.addEventListener("DOMContentLoaded", () => {
  const canvas = document.getElementById("paramCanvas");
  const ctx = canvas.getContext("2d");
  const paramRange = document.getElementById("paramRange");
  const paramValue = document.getElementById("paramValue");
  const paramLabel = document.getElementById("paramLabel");
  const hintBtn = document.getElementById("hintBtn");
  const hintBox = document.getElementById("hintBox");
  const tabs = document.querySelectorAll(".tab-btn");
  const animateBtn = document.getElementById("animateBtn");
  const resetBtn = document.getElementById("resetBtn");

  const width = canvas.width;
  const height = canvas.height;
  const scaleX = 40;
  const scaleY = 40;

  let currentEq = "p1";
  let animating = false;
  let animationFrame = null;
  let tVal = -3;

  // Draw axes
  function drawAxes() {
    ctx.clearRect(0, 0, width, height);
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#888";
    ctx.beginPath();
    ctx.moveTo(0, height/2);
    ctx.lineTo(width, height/2);
    ctx.moveTo(width/2, 0);
    ctx.lineTo(width/2, height);
    ctx.stroke();
  }

  // Convert math coords â†’ canvas coords
  function toCanvas(x, y) {
    return [width/2 + x*scaleX, height/2 - y*scaleY];
  }

  // Parametric equations and hints
  const eqs = {
    p1: {
      label: "t",
      hint: "This creates a parabola (y = xÂ²) traced from left to right as t increases.",
      tmin: -3, tmax: 3,
      func: t => ({ x: t, y: t*t }),
      drawColor: "#3b82f6"
    },
    p2: {
      label: "t",
      hint: "This makes a straight line â€” as t changes, the point moves along a diagonal line.",
      tmin: -1, tmax: 5,
      func: t => ({ x: t - 1, y: 2*t - 1 }),
      drawColor: "#f97316"
    },
    p3: {
      label: "Î¸",
      hint: "This forms a hyperbola segment for secÎ¸ and tanÎ¸ â€” notice asymptotes as Î¸ approaches Â±90Â°!",
      tmin: -1.3, tmax: 1.3, // avoid infinite tan
      func: Î¸ => ({ x: 1/Math.cos(Î¸), y: Math.tan(Î¸) }),
      drawColor: "#22c55e"
    }
  };

  function drawCurve(eq) {
    drawAxes();
    ctx.strokeStyle = eq.drawColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;
    for (let t = eq.tmin; t <= eq.tmax; t += 0.01) {
      const {x, y} = eq.func(t);
      const [cx, cy] = toCanvas(x, y);
      if (!started) { ctx.moveTo(cx, cy); started = true; }
      else ctx.lineTo(cx, cy);
    }
    ctx.stroke();
  }

  function drawPoint(eq, t) {
    const {x, y} = eq.func(t);
    const [cx, cy] = toCanvas(x, y);
    ctx.fillStyle = eq.drawColor;
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI*2);
    ctx.fill();
  }

  function render() {
    const eq = eqs[currentEq];
    drawCurve(eq);
    drawPoint(eq, tVal);
    paramLabel.textContent = eq.label + ":";
    paramRange.min = eq.tmin;
    paramRange.max = eq.tmax;
    paramRange.value = tVal;
    paramValue.textContent = tVal.toFixed(2);
  }

  // Update when slider moves
  paramRange.addEventListener("input", e => {
    tVal = parseFloat(e.target.value);
    render();
  });

  // Tabs
  tabs.forEach(tab => {
    tab.addEventListener("click", () => {
      tabs.forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      currentEq = tab.dataset.eq;
      tVal = eqs[currentEq].tmin;
      render();
      hintBox.textContent = "";
    });
  });

  // Animation
  animateBtn.addEventListener("click", () => {
    if (animating) {
      cancelAnimationFrame(animationFrame);
      animating = false;
      animateBtn.textContent = "â–¶ Animate";
      return;
    }
    animating = true;
    animateBtn.textContent = "â¸ Pause";
    const eq = eqs[currentEq];
    function step() {
      if (!animating) return;
      tVal += 0.03;
      if (tVal > eq.tmax) tVal = eq.tmin;
      render();
      animationFrame = requestAnimationFrame(step);
    }
    step();
  });

  // Reset
  resetBtn.addEventListener("click", () => {
    animating = false;
    cancelAnimationFrame(animationFrame);
    animateBtn.textContent = "â–¶ Animate";
    tVal = eqs[currentEq].tmin;
    render();
  });

  // Hint
  hintBtn.addEventListener("click", () => {
    hintBox.textContent = eqs[currentEq].hint;
  });

  render();
});

// ğŸ§© Continuity Explorer (SVG version)
document.addEventListener("DOMContentLoaded", () => {
  const svg = document.getElementById("graph");
  const pathEl = document.getElementById("graphPath");
  const pointEl = document.getElementById("point");
  const holeEl = document.getElementById("hole");
  const filledEl = document.getElementById("filled");
  const hintBox = document.getElementById("hintBox");
  const hintBtn = document.getElementById("hintBtn");
  const tabs = document.querySelectorAll(".tab-btn");
  const xSlider = document.getElementById("xSlider");
  const xValue = document.getElementById("xValue");

  const width = 480, height = 320, scaleX = 60, scaleY = 40;
  const originX = width/2, originY = height/2;
  let current = "f1";

  const funcs = {
    f1: {
      color: "#3b82f6",
      func: x => (x < 3 ? x - 1 : 2*x + 1),
      domain: [0,6],
      hole: {x:3, y:2},
      hint: "At x=3, left limit=2 and right value=7 â†’ jump discontinuity."
    },
    f2: {
      color: "#f97316",
      func: x => (x===2?NaN:(x*x - 4)/(x - 2)),
      domain: [0,5],
      hole: {x:2, y:4},
      hint: "Simplifies to y=x+2 with hole at x=2 â†’ removable discontinuity."
    },
    f3: {
      color: "#22c55e",
      func: x => (x===3?2:x+3),
      domain: [0,6],
      hole: {x:3, y:6},
      filled: {x:3, y:2},
      hint: "At x=3, limit=6 but value=2 â†’ not continuous."
    },
    f4: {
      color: "#a855f7",
      func: x => (x===4?NaN:(x*x - 16)/(x - 4)),
      domain: [0,6],
      hole: {x:4, y:8},
      hint: "Simplifies to y=x+4 with a hole at x=4 â†’ removable discontinuity."
    }
  };

  function toCanvas(x, y) {
    return [originX + x*scaleX, originY - y*scaleY];
  }

  function drawGraph(id) {
    const f = funcs[id];
    const pts = [];
    for (let x = f.domain[0]; x <= f.domain[1]; x += 0.02) {
      const y = f.func(x);
      if (isNaN(y) || y > 10 || y < -10) continue;
      const [cx, cy] = toCanvas(x, y);
      pts.push(`${cx},${cy}`);
    }
    pathEl.setAttribute("stroke", f.color);
    pathEl.setAttribute("d", "M" + pts.join(" L"));
    holeEl.style.display = "none";
    filledEl.style.display = "none";
    if (f.hole) {
      const [hx, hy] = toCanvas(f.hole.x, f.hole.y);
      holeEl.setAttribute("cx", hx);
      holeEl.setAttribute("cy", hy);
      holeEl.style.display = "block";
    }
    if (f.filled) {
      const [fx, fy] = toCanvas(f.filled.x, f.filled.y);
      filledEl.setAttribute("cx", fx);
      filledEl.setAttribute("cy", fy);
      filledEl.style.display = "block";
    }
    xSlider.min = f.domain[0];
    xSlider.max = f.domain[1];
    hintBox.textContent = "";
    renderPoint(f.domain[0]);
  }

  function renderPoint(x) {
    const f = funcs[current];
    const y = f.func(x);
    xValue.textContent = x.toFixed(2);
    if (isNaN(y)) { pointEl.style.display = "none"; return; }
    const [cx, cy] = toCanvas(x, y);
    pointEl.setAttribute("cx", cx);
    pointEl.setAttribute("cy", cy);
    pointEl.setAttribute("fill", f.color);
    pointEl.style.display = "block";
  }

  tabs.forEach(t => {
    t.addEventListener("click", () => {
      tabs.forEach(b => b.classList.remove("active"));
      t.classList.add("active");
      current = t.dataset.eq;
      drawGraph(current);
    });
  });

  xSlider.addEventListener("input", e => {
    renderPoint(parseFloat(e.target.value));
  });

  hintBtn.addEventListener("click", () => {
    hintBox.textContent = funcs[current].hint;
  });

  drawGraph(current);
});


document.addEventListener("DOMContentLoaded", function () {
  // DOM elements
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const eqButtons = Array.from(document.querySelectorAll("#eqButtons .eq-btn"));
  const showStepsBtn = document.getElementById("showStepsBtn");
  const hideStepsBtn = document.getElementById("hideStepsBtn");
  const stepsBox = document.getElementById("stepsBox");

  // canvas coords
  const W = canvas.width, H = canvas.height;
  const originX = W / 2, originY = H / 2;
  const scaleX = 80; // pixels per unit (x)
  const scaleY = 80; // pixels per unit (y)

  // state
  let activeEq = "eq1";

  // equation definitions (left(x) and right(x) functions)
  const equations = {
    eq1: {
      title: "x = sin(2x)",
      left: x => x,
      right: x => Math.sin(2 * x),
      domain: [-3.5, 3.5],
      steps: [
        "Rewrite as y = x and y = sin(2x).",
        "Plot both curves on the same axes (a straight line and a sine wave).",
        "Graphical solutions are the x-values where the curves meet (intersections).",
        "Use numerical methods or careful reading of the graph to approximate intersections (e.g. x â‰ˆ 0, Â±1.8)."
      ]
    },
    eq2: {
      title: "x/2 = cos(x)",
      left: x => x / 2,
      right: x => Math.cos(x),
      domain: [-6, 6],
      steps: [
        "Rewrite as y = x/2 and y = cos(x).",
        "The line y = x/2 grows slowly; cos(x) oscillates between -1 and 1.",
        "Intersections occur where the linear line crosses the cosine curve.",
        "Expect roughly one positive and one negative intersection in this wide domain."
      ]
    },
    eq3: {
      title: "2x = tan(x)",
      left: x => 2 * x,
      right: x => Math.tan(x),
      domain: [-1.4, 1.4], // avoid tan asymptotes
      steps: [
        "Rewrite as y = 2x and y = tan(x).",
        "tan(x) has vertical asymptotes; restrict to a safe central range.",
        "Plot both; the main intersection is near x = 0.",
        "Graphical approx plus refinement (e.g. bisection) gives the numeric root."
      ]
    }
  };

  // utility: convert math coords to canvas pixels
  function toCanvas(x, y) {
    return [ originX + x * scaleX, originY - y * scaleY ];
  }

  // draw axes and light grid
  function drawAxes() {
    ctx.clearRect(0, 0, W, H);

    // light grid
    ctx.strokeStyle = "#f1f8ff";
    ctx.lineWidth = 1;
    const xUnits = Math.floor(W / (2 * scaleX));
    const yUnits = Math.floor(H / (2 * scaleY));
    for (let u = -xUnits; u <= xUnits; u++) {
      const cx = toCanvas(u, 0)[0];
      ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, H); ctx.stroke();
    }
    for (let v = -yUnits; v <= yUnits; v++) {
      const cy = toCanvas(0, v)[1];
      ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(W, cy); ctx.stroke();
    }

    // axes
    ctx.strokeStyle = "#9aa6b2"; ctx.lineWidth = 1.4;
    ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(W, originY); ctx.moveTo(originX, 0); ctx.lineTo(originX, H); ctx.stroke();

    // origin label
    ctx.fillStyle = "#123"; ctx.font = "12px sans-serif";
    ctx.fillText("0", originX + 4, originY - 6);
  }

  // draw one function on domain
  function drawFunction(fn, color, domain) {
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;
    const samples = 2000;
    for (let i = 0; i <= samples; i++) {
      const x = domain[0] + (domain[1] - domain[0]) * (i / samples);
      let y;
      try { y = fn(x); } catch (e) { y = NaN; }
      if (!isFinite(y) || Math.abs(y) > 1e3) { started = false; continue; }
      const [cx, cy] = toCanvas(x, y);
      if (!started) { ctx.moveTo(cx, cy); started = true; } else ctx.lineTo(cx, cy);
    }
    ctx.stroke();
  }

  // find approximate intersections by sampling sign changes, then refine via bisection
  function findIntersections(leftFn, rightFn, domain) {
    function g(x) {
      const L = leftFn(x), R = rightFn(x);
      if (!isFinite(L) || !isFinite(R)) return NaN;
      return L - R;
    }
    const roots = [];
    const N = 1200;
    let prevX = domain[0];
    let prevG = g(prevX);
    for (let i = 1; i <= N; i++) {
      const x = domain[0] + (domain[1] - domain[0]) * (i / N);
      const gx = g(x);
      if (!isFinite(gx)) { prevX = x; prevG = gx; continue; }
      if (isFinite(prevG) && prevG * gx < 0) {
        // bisection refine
        let a = prevX, b = x, fa = prevG, fb = gx;
        for (let it = 0; it < 40; it++) {
          const m = 0.5 * (a + b);
          const fm = g(m);
          if (!isFinite(fm)) break;
          if (Math.abs(fm) < 1e-12) { a = b = m; break; }
          if (fa * fm <= 0) { b = m; fb = fm; } else { a = m; fa = fm; }
        }
        const root = 0.5 * (a + b);
        if (!roots.some(r => Math.abs(r - root) < 1e-8)) roots.push(root);
      } else if (isFinite(gx) && Math.abs(gx) < 1e-10) {
        if (!roots.some(r => Math.abs(r - x) < 1e-8)) roots.push(x);
      }
      prevX = x; prevG = gx;
    }
    roots.sort((a,b)=>a-b);
    return roots;
  }

  // render current equation: both sides + intersections + short summary
  function renderCurrent() {
    const eq = equations[activeEq];
    drawAxes();
    // left (blue) and right (red)
    drawFunction(eq.left, "#1f6feb", eq.domain);
    drawFunction(eq.right, "#ef4444", eq.domain);

    // intersections
    const roots = findIntersections(eq.left, eq.right, eq.domain);
    ctx.font = "12px sans-serif";
    roots.forEach(r => {
      const y = eq.left(r);
      if (!isFinite(y)) return;
      const [cx, cy] = toCanvas(r, y);
      // marker
      ctx.beginPath();
      ctx.fillStyle = "#ff7b6b";
      ctx.arc(cx, cy, 6, 0, Math.PI*2);
      ctx.fill();
      // label
      ctx.fillStyle = "#052a36";
      ctx.fillText(`x=${r.toFixed(4)}`, cx + 8, cy - 8);
    });

    // summary (only show short summary unless steps requested)
    if (!stepsBox.dataset.showingSteps || stepsBox.dataset.showingSteps === "false") {
      stepsBox.innerHTML = `<div style="font-weight:700">${eq.title}</div>
        <div style="margin-top:8px;">Found <strong>${roots.length}</strong> intersection(s): ${roots.length ? roots.map(r=>r.toFixed(6)).join(", ") : "none (in domain)"}.</div>
        <div style="margin-top:8px; color:#356;">Click "Show Steps" for a calm step-by-step explanation.</div>`;
    }
  }

  // wire tab buttons
  eqButtons.forEach(btn => {
    btn.addEventListener("click", function () {
      eqButtons.forEach(b => b.classList.remove("active"));
      this.classList.add("active");
      activeEq = this.dataset.eq;
      stepsBox.dataset.showingSteps = "false";
      renderCurrent();
    });
  });

  // show steps: populate stepsBox with ordered steps
  showStepsBtn.addEventListener("click", function () {
    const eq = equations[activeEq];
    let html = `<div style="font-weight:800; margin-bottom:8px;">${eq.title} â€” Steps</div><ol style="margin-left:18px;">`;
    for (let s of eq.steps) html += `<li style="margin-bottom:8px;">${s}</li>`;
    html += `</ol><div style="margin-top:8px;color:#0b6623;">Tip: the orange markers are numerical approximations; refine analytically if precise roots are required.</div>`;
    stepsBox.innerHTML = html;
    stepsBox.dataset.showingSteps = "true";
  });

  // hide steps: go back to short summary + graph
  hideStepsBtn.addEventListener("click", function () {
    stepsBox.dataset.showingSteps = "false";
    renderCurrent();
  });

  // initial render
  stepsBox.dataset.showingSteps = "false";
  renderCurrent();
});






  </script>
</body>
</html>
